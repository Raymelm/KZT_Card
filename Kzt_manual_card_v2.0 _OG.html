<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kzt Card Style Preview</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Using Inter font from Google Fonts for a clean look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        :root {
            --card-transition-duration: 200ms;
            --section-transition-duration: 450ms;
            --fade-duration: 300ms;
            --hover-duration: 200ms;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Tailwind slate-200 for more contrast */
        }

        /* --- KZT Card Professional Styling --- */

        .kzt-card-skipped {
            border: 1px dashed #dbe1e9;
            border-radius: 8px;
            padding: 12px;
            background: #f8fafc;
            color: #64748b;
            opacity: 0.8;
        }

        .kzt-card, .manager-card, .controlling-case-card {
            background: #ffffff;
            border: 1px solid #e2e8f0; /* Softer border color */
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -2px rgba(0, 0, 0, 0.07);
        }

        .kzt-card {
            /* Base transition for hover effects */
            transition: transform var(--card-transition-duration) cubic-bezier(0.2, 0.8, 0.2, 1),
                        box-shadow var(--card-transition-duration) cubic-bezier(0.2, 0.8, 0.2, 1),
                        opacity var(--fade-duration) ease-out, 
                        filter var(--fade-duration) ease-out;
            cursor: grab;
        }

        .kzt-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -4px rgba(0, 0, 0, 0.08);
        }

        .kzt-card:active {
            cursor: grabbing;
            box-shadow: 0 1px 2px rgba(45, 59, 67, 0.08);
            transition-duration: 0.05s;
        }
        
        .kzt-card.is-excluded {
            opacity: 0.65;
            filter: grayscale(50%);
        }

        /* --- Manager & Controlling Card Specific Styles --- */
        .manager-card {
            background-color: #e2e8f0; /* slate-200 */
            border-color: #d1d5db;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .manager-card:hover {
            box-shadow: 0 8px 12px -2px rgba(0, 0, 0, 0.12), 0 4px 8px -2px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }
        .manager-controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            align-items: end;
        }
        .control-group {
            transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .control-group:hover {
            transform: translateY(-1px);
        }
        .control-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600; /* Bolder label */
            color: #374151; /* slate-700 */
            margin-bottom: 4px;
            transition: color 0.2s ease-out;
        }
        .control-group:hover label {
            color: #1f2937;
        }
        .control-group select, .control-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #cbd5e1; /* slate-300 */
            background-color: #fff;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            border-radius: 6px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        .control-group select:hover, .control-group input:hover {
            border-color: #94a3b8;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .control-group select:focus, .control-group input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1), 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        .control-group select:active, .control-group input:active {
            transform: translateY(0);
            transition-duration: 0.1s;
        }
        /* Enhanced dropdown arrow animation */
        .control-group select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 8px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 32px;
            appearance: none;
        }
        .control-group select:hover {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%234f46e5' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        }
        /* Input group styling */
        .control-group .flex input {
            border-radius: 6px 0 0 6px;
        }
        .control-group .flex select {
            border-radius: 0 6px 6px 0;
            border-left: 0;
        }
        /* Checkbox styling */
        .control-group input[type="checkbox"] {
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .control-group input[type="checkbox"]:hover {
            transform: scale(1.05);
        }
        .control-group input[type="checkbox"]:focus {
            transform: scale(1.05);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        /* Switch Toggle Styling */
        .toggle-bg {
            transition: background-color 0.2s ease-in-out;
        }
        .toggle-dot {
            transition: transform 0.2s ease-in-out;
        }
        input:checked + div .toggle-bg {
            background-color: #4f46e5; /* indigo-600 */
        }
        input:checked + div .toggle-dot {
            transform: translateX(1rem) translateY(0.25rem); /* translate-x-4 translate-y-1 */
        }
        .control-group label:hover .toggle-bg {
            background-color: #6b7280; /* gray-500 */
        }
        .control-group label:hover input:checked + div .toggle-bg {
            background-color: #3730a3; /* indigo-700 */
        }
        .controlling-case-card {
            border-left: 4px solid #5b21b6; /* darker violet-800 */
            background-color: #f5f3ff; /* violet-50 */
            transition: all var(--fade-duration) cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
            transform-origin: top;
        }
        .controlling-case-card.case-changing {
            animation: caseTransition var(--fade-duration) ease-out;
        }
        @keyframes caseTransition {
            0% { transform: scaleY(1); opacity: 1; }
            50% { transform: scaleY(0.95); opacity: 0.7; background-color: #f8fafc; }
            100% { transform: scaleY(1); opacity: 1; }
        }
        .controlling-case-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.05), transparent);
            transition: left 0.8s ease;
        }
        .controlling-case-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px -4px rgba(91, 33, 182, 0.15), 0 4px 8px -2px rgba(0, 0, 0, 0.08);
            border-left-color: #7c3aed;
        }
        .controlling-case-card:hover::before {
            left: 100%;
        }
        /* Increased contrast for controlling card text */
        .controlling-case-card .card-header strong { color: #5b21b6; }
        .controlling-case-card .info-grid span { color: #334155; } /* slate-700 */
        .controlling-case-card .info-grid strong { color: #020617; } /* slate-950 */
        
        /* Controlling case content animations */
        .controlling-case-content {
            position: relative;
            overflow: hidden;
            display: grid;
            /* Use a slower transition for more dramatic collapse effect */
            transition: max-height calc(var(--section-transition-duration) * 1.5) cubic-bezier(0.2, 0.8, 0.2, 1);
            max-height: 2000px; /* Default expanded state */
        }
        .controlling-data-container,
        .no-data-message {
            transition: opacity var(--section-transition-duration) ease-out,
                       transform var(--section-transition-duration) ease-out;
        }


        /* --- ANIMATION & COLLAPSE STYLES --- */
        .kzt-card-ghost {
            position: fixed; z-index: 100; pointer-events: none; margin: 0;
            transition: transform var(--section-transition-duration) cubic-bezier(0.2, 0.8, 0.2, 1), opacity var(--fade-duration) ease-out;
            transform-origin: top left;
        }
        .kzt-card-restoring {
            transform-origin: top left;
            transition: transform var(--section-transition-duration) cubic-bezier(0.2, 0.8, 0.2, 1), opacity var(--fade-duration) ease-out 0.05s;
        }
        .collapsed-badge.is-animating {
            opacity: 0; transform: scale(0.8); transition: opacity var(--fade-duration) ease-out, transform var(--fade-duration) ease-out;
        }
        .kzt-card.is-hiding {
            opacity: 0;
            transform: scale(0.95);
            transition: opacity var(--fade-duration) ease-out, transform var(--fade-duration) ease-out;
        }


        /* --- Collapsed Bar Styles --- */
        #collapsed-bar {
            background-color: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 8px;
            padding: 8px; min-height: 50px;
            transition: all var(--card-transition-duration) ease-out;
            transform-origin: top;
        }
        #collapsed-bar.dock-appearing {
            animation: slideDownFade var(--card-transition-duration) ease-out;
        }
        #collapsed-bar.dock-updating {
            animation: gentlePulse var(--card-transition-duration) ease-out;
        }
        @keyframes slideDownFade {
            from {
                opacity: 0;
                transform: translateY(-10px) scaleY(0.95);
                max-height: 0;
                padding: 0 8px;
            }
            to {
                opacity: 1;
                transform: translateY(0) scaleY(1);
                max-height: 200px;
                padding: 8px;
            }
        }
        @keyframes gentlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        }
        .collapsed-badge {
            display: inline-flex; align-items: center; padding: 4px 10px; border-radius: 16px;
            font-size: 0.875rem; font-weight: 500; cursor: pointer; 
            transition: all var(--hover-duration);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .collapsed-badge.badge-entering {
            animation: badgeSlideIn var(--card-transition-duration) ease-out;
        }
        @keyframes badgeSlideIn {
            from {
                opacity: 0;
                transform: translateX(-20px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }
        
        /* Controlling Case Card Animation */
        .controlling-case-card {
            transition: all var(--card-transition-duration) ease;
        }
        
        .controlling-case-card.case-changing {
            opacity: 0;
            transform: scale(0.98);
        }
        
        .collapsed-badge:hover {
            transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .collapsed-badge svg { margin-right: 4px; width: 16px; height: 16px; }

        /* --- Control Panel Styles --- */
        .control-panel {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        .control-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.8s ease;
        }
        .control-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }
        .control-panel:hover::before {
            left: 100%;
        }
        .control-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e2e8f0;
        }
        .control-panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-panel-title svg {
            width: 20px;
            height: 20px;
            color: #6366f1;
        }
        .control-panel-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            /* Make all three subcontainers equal height */
            align-items: stretch;
        }
        .control-panel-grid.grid-cols-3 {
            grid-template-columns: repeat(3, 1fr);
        }
        .control-group {
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            /* Fill row height and stack inner controls */
            display: flex;
            flex-direction: column;
        }
        .control-group:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: #cbd5e1;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .control-group-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #475569;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .control-column {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1 1 auto;
        }
        .control-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }
        .control-btn svg {
            width: 14px;
            height: 14px;
        }
        .control-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .control-btn:active {
            transform: translateY(0);
            transition-duration: 0.1s;
        }
        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        /* Primary control button */
        .control-btn-primary {
            background-color: #6366f1;
            color: white;
        }
        .control-btn-primary:hover {
            background-color: #5b21b6;
            box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
        }
        /* Secondary control button */
        .control-btn-secondary {
            background-color: #f1f5f9;
            color: #475569;
            border-color: #cbd5e1;
        }
        .control-btn-secondary:hover {
            background-color: #e2e8f0;
            border-color: #94a3b8;
            color: #334155;
        }
        /* Danger control button */
        .control-btn-danger {
            background-color: #ef4444;
            color: white;
        }
        .control-btn-danger:hover {
            background-color: #dc2626;
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }
        /* Success control button */
        .control-btn-success {
            background-color: #10b981;
            color: white;
        }
        .control-btn-success:hover {
            background-color: #059669;
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
        }
        /* Toggle switch in control panel */
        .control-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-wrap: nowrap;
            max-width: 100%;
            min-width: 0; /* allow children to shrink */
            overflow: hidden; /* prevent spillover */
        }
        .control-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #cbd5e1;
        }
        .control-toggle-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            flex: 1 1 auto; /* take remaining space */
            min-width: 0; /* enable ellipsis */
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Enhanced toggle switch styling for control panel */
        .control-toggle input[type="checkbox"] {
            position: relative;
            width: 44px;
            height: 24px;
            appearance: none;
            background-color: #d1d5db;
            border-radius: 12px;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }
        .control-toggle input[type="checkbox"]:checked {
            background-color: #6366f1;
        }
        .control-toggle input[type="checkbox"]::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .control-toggle input[type="checkbox"]:checked::before {
            transform: translateX(20px);
        }
        .control-toggle input[type="checkbox"]:hover {
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        /* Control slider styles */
        .control-slider-container {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            transition: all 0.2s ease;
        }
        .control-slider-container:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #cbd5e1;
        }
        .control-slider-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
        }
        .control-slider-wrapper {
            position: relative;
        }
        .control-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            appearance: none;
            cursor: pointer;
        }
        .control-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        .control-slider::-webkit-slider-thumb:hover {
            background: #5b21b6;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
        }
        .control-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        .control-slider::-moz-range-thumb:hover {
            background: #5b21b6;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
        }
        .control-slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
            font-size: 0.75rem;
            color: #64748b;
        }
        /* Inline slider for single-line layout */
        .control-slider-inline {
            width: 56px; /* narrower to avoid overflow */
            height: 4px;
            border-radius: 2px;
            background: #e2e8f0;
            outline: none;
            appearance: none;
            cursor: pointer;
            flex: 0 0 auto;
        }
        .speed-value {
            font-size: 0.78rem;
            color: #64748b;
            margin-left: 4px;
            flex: 0 0 auto;
        }
        .control-slider-inline::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        .control-slider-inline::-webkit-slider-thumb:hover {
            background: #5b21b6;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(99, 102, 241, 0.3);
        }
        .control-slider-inline::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        .control-slider-inline::-moz-range-thumb:hover {
            background: #5b21b6;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(99, 102, 241, 0.3);
        }
        /* Status indicators */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .status-visible {
            background-color: #dcfce7;
            color: #166534;
        }
        .status-hidden {
            background-color: #fef3c7;
            color: #92400e;
        }
        .status-docked {
            background-color: #dbeafe;
            color: #1e40af;
        }

        /* --- Internal Card Layout & Typography --- */

        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 1.1em; color: #1e293b;
        }
        .card-content { padding-top: 12px; }
        /* --- Loading Animation Styles --- */
        .fade-in-up {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }
        .fade-in-up.delay-1 { animation-delay: 0.1s; }
        .fade-in-up.delay-2 { animation-delay: 0.2s; }
        .fade-in-up.delay-3 { animation-delay: 0.3s; }
        .fade-in-up.delay-4 { animation-delay: 0.4s; }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Enhanced final kzt display */
        .final-kzt-display {
            background-color: #eef2ff; padding: 6px 10px; border-radius: 6px; color: #3730a3;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .final-kzt-display:hover {
            background-color: #e0e7ff;
            transform: scale(1.02);
            box-shadow: 0 2px 4px rgba(55, 48, 163, 0.1);
        }
    .final-kzt-value { font-weight: 700; }
    /* Ensure subscript for Kzt is visually a subscript */
    .final-kzt-display sub { vertical-align: sub; font-size: 0.85em; line-height: 0; }
        .info-container {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px;
        }
        .info-section {
            background-color: #f8fafc; border-radius: 6px; padding: 12px; border: 1px solid #e2e8f0;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .info-section:hover {
            background-color: #f1f5f9;
            border-color: #cbd5e1;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .section-title {
            font-size: 0.75rem; font-weight: 600; color: #334155;
            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px;
            transition: color 0.2s ease;
        }
        .info-section:hover .section-title {
            color: #1e293b;
        }
        .info-grid {
            display: grid; grid-template-columns: auto 1fr; gap: 4px 12px; font-size: 0.9em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            color: #475569;
        }
        .info-grid strong {
            color: #1e293b; font-weight: 500; text-align: right;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 3px;
            padding: 1px 3px;
            /* user-select: none; REMOVED to allow double-click text selection */
        }
        .info-grid strong:hover {
            background-color: #e2e8f0;
            color: #0f172a;
            transform: scale(1.02);
        }
        
        /* --- Card Section Collapse Styles --- */
        .card-section-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; background-color: #f8fafc; border-radius: 6px;
            cursor: pointer; border: 1px solid #e2e8f0; margin-top: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        .card-section-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s ease;
        }
        .card-section-header:hover {
            background-color: #f1f5f9;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .card-section-header:hover::before {
            left: 100%;
        }
        .card-section-header:active {
            transform: translateY(0);
            transition-duration: 0.1s;
        }
        .card-section-title { 
            font-weight: 600; 
            color: #334155; 
            transition: color 0.2s ease;
        }
        .card-section-header:hover .card-section-title {
            color: #1e293b;
        }
        .card-section-toggle { 
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), color 0.2s ease;
            color: #64748b;
        }
        .card-section-toggle.is-collapsed { 
            transform: rotate(-90deg); 
        }
        .card-section-header:hover .card-section-toggle {
            color: #475569;
        }
        .collapsible-content {
            display: grid;
            overflow: hidden;
            /* Use CSS variables so animationSpeed controls timing. Fallback to 450ms if variable missing. */
            transition: max-height var(--section-transition-duration, 450ms) cubic-bezier(0.2, 0.8, 0.2, 1);
            max-height: 2000px; /* Default expanded state */
        }
        .collapsible-content.is-collapsed {
            max-height: 0;
        }
        .collapsible-content > div {
            /* Use variables for coordinated timing */
            transition: opacity var(--fade-duration, 300ms) ease-out, padding var(--section-transition-duration, 450ms) cubic-bezier(0.2, 0.8, 0.2, 1);
            padding: 12px 4px 4px 4px;
            opacity: 1;
            min-height: 0;
        }
        .collapsible-content.is-collapsed > div {
            opacity: 0;
            padding: 0 4px;
        }
        .chart-container {
            position: relative;
            height: 300px;
            z-index: 1; /* keep canvas below toggle */
        }

        /* Matrix Table */
        .kzt-matrix-table { 
            width: 100%; border-collapse: collapse; font-size: 0.9em; text-align: center;
            transition: all 0.3s ease;
        }
        .kzt-matrix-table th, .kzt-matrix-table td { 
            border: 1px solid #f1f5f9; padding: 8px 6px; vertical-align: middle;
            transition: all 0.2s ease;
        }
        .kzt-matrix-table th { 
            background-color: #f8fafc; color: #475569; font-weight: 500;
        }
        .kzt-matrix-table td:first-child { 
            text-align: left; font-weight: 500; color: #334155;
            transition: color 0.2s ease;
        }
        .kzt-matrix-table tr:hover td {
            background-color: #f8fafc;
        }
        .kzt-matrix-table tr:hover td:first-child {
            color: #1e293b;
        }
        .kzt-matrix-table .radio-label { 
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            gap: 6px; white-space: nowrap;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
            padding: 4px;
        }
        .kzt-matrix-table .radio-label:hover {
            background-color: #eef2ff;
            transform: scale(1.02);
        }
        .kzt-matrix-table input[type="radio"] {
            appearance: none; background-color: #fff; margin: 0; font: inherit; color: currentColor; 
            width: 1.15em; height: 1.15em; border: 0.15em solid #cbd5e1; border-radius: 50%; 
            transform: translateY(-0.075em); display: grid; place-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .kzt-matrix-table input[type="radio"]:hover {
            border-color: #94a3b8;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
        }
        .kzt-matrix-table input[type="radio"]::before {
            content: ""; width: 0.65em; height: 0.65em; border-radius: 50%; transform: scale(0);
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: inset 1em 1em #4f46e5;
        }
        .kzt-matrix-table input[type="radio"]:checked::before { 
            transform: scale(1); 
        }
        .kzt-matrix-table input[type="radio"]:checked { 
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }

        /* Expandable View Toolbar */
        .expandable-view-toolbar {
            position: relative;
            display: flex;
            align-items: center;
            z-index: 60;
            margin: 0 0 8px 0; /* Align with chart-tools spacing */
        }

        .view-panel-container {
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            backdrop-filter: blur(12px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 2px 8px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            height: 48px;
            min-width: -webkit-fill-available; /* Samsung Internet fallback */
        }

        .view-panel-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.03) 0%, rgba(139, 92, 246, 0.03) 100%);
            pointer-events: none;
        }

        .view-panel-container:hover {
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.15),
                0 4px 12px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
        }

        /* Always visible core section */
        .view-panel-core {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            flex-shrink: 0;
            position: relative;
            z-index: 2;
        }

        /* R/D Switch Integration */
        .view-mode-switch {
            display: flex;
            gap: 2px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            border-radius: 10px;
            padding: 3px;
            margin-right: 8px;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }
        
        .view-toggle-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: #64748b;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .view-toggle-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .view-toggle-btn:hover {
            background: rgba(226, 232, 240, 0.5);
            color: #475569;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .view-toggle-btn:hover::before {
            opacity: 1;
        }

        .view-toggle-btn.active {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            color: white;
            box-shadow: 
                0 4px 16px rgba(79, 70, 229, 0.3),
                0 2px 8px rgba(79, 70, 229, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .view-toggle-btn.active:hover {
            background: linear-gradient(135deg, #4338ca 0%, #5b21b6 100%);
            box-shadow: 
                0 6px 20px rgba(79, 70, 229, 0.4),
                0 3px 10px rgba(79, 70, 229, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* Expand/Collapse Button */
        .panel-expand-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            color: #64748b;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
        }

        .panel-expand-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .panel-expand-btn:hover {
            background: rgba(99, 102, 241, 0.1);
            color: #4f46e5;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
        }

        .panel-expand-btn:hover::before {
            opacity: 1;
        }

        .panel-expand-btn.expanded {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            color: white;
            transform: rotate(180deg) translateY(1px);
            box-shadow: 
                0 4px 16px rgba(79, 70, 229, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Expandable content section */
        .view-panel-expandable {
            display: flex;
            align-items: center;
            padding: 8px 0;
            width: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            white-space: nowrap;
        }

        .view-panel-expandable.expanded {
            width: 560px; /* Increased width to properly accommodate all tools */
            opacity: 1;
            padding: 8px 12px 8px 0;
        }

        .view-panel-expandable.transitioning {
            overflow: hidden;
        }

        /* Chart Display Mode Controls */
        .chart-display-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            min-width: -webkit-fill-available; /* Samsung Internet fallback */
        }

        .display-mode-label {
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 4px;
            flex-shrink: 0;
        }

        .display-mode-toggle {
            display: flex;
            gap: 2px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            border-radius: 8px;
            padding: 2px;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }

        .display-mode-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: #64748b;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }

        .display-mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .display-mode-btn:hover {
            background: rgba(226, 232, 240, 0.5);
            color: #475569;
            transform: translateY(-1px);
        }

        .display-mode-btn:hover::before {
            opacity: 1;
        }

        .display-mode-btn.active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 
                0 3px 12px rgba(16, 185, 129, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .display-mode-btn.active:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        /* Integrated Chart Tools */
        .chart-tools-integrated {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            min-width: -webkit-fill-available; /* Samsung Internet fallback */
        }

        .tool-separator {
            width: 1px;
            height: 24px;
            background: linear-gradient(180deg, transparent 0%, rgba(226, 232, 240, 0.6) 20%, rgba(226, 232, 240, 0.6) 80%, transparent 100%);
            flex-shrink: 0;
        }

        /* Smart Toggle Button (Annotations) */
        .smart-toggle-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            color: #64748b;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }

        .smart-toggle-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .smart-toggle-btn:hover {
            background: rgba(226, 232, 240, 0.5);
            color: #475569;
            transform: translateY(-1px);
        }

        .smart-toggle-btn:hover::before {
            opacity: 1;
        }

        .smart-toggle-btn.active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 
                0 3px 12px rgba(16, 185, 129, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .smart-toggle-btn.active:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .toggle-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        .toggle-text {
            font-size: 11px;
            font-weight: 600;
        }

        /* Sophisticated Dropdown System */
        .dropdown-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .dropdown-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border: none;
            border-radius: 8px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            color: #64748b;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }

        .dropdown-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dropdown-btn:hover {
            background: rgba(99, 102, 241, 0.1);
            color: #4f46e5;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
        }

        .dropdown-btn:hover::before {
            opacity: 1;
        }

        .dropdown-btn.active {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            color: white;
            box-shadow: 
                0 4px 16px rgba(79, 70, 229, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .dropdown-btn.active:hover {
            background: linear-gradient(135deg, #4338ca 0%, #5b21b6 100%);
        }

        .dropdown-btn.pending {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            animation: pulseGlow 2s ease-in-out infinite;
        }

        .dropdown-arrow {
            width: 12px;
            height: 12px;
            flex-shrink: 0;
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .dropdown-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 34px;
            height: 34px;
            padding: 4px;
            margin-left: 6px;
            border-radius: 8px;
            border: none;
            background: rgba(248, 250, 252, 0.8);
            cursor: pointer;
            transition: background 0.2s ease, transform 0.12s ease;
        }

        .dropdown-toggle:hover { background: rgba(226,232,240,0.6); transform: translateY(-1px); }

        .dropdown-container.open .dropdown-arrow {
            transform: rotate(180deg);
        }

        /* Dropdown Menu */
        .dropdown-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            background: rgba(255, 255, 255, 0.98);
            -webkit-backdrop-filter: blur(20px) saturate(200%);
            backdrop-filter: blur(20px) saturate(200%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px) scale(0.95);
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 100;
            min-width: 140px;
            padding: 4px;
        }

        .dropdown-container.open .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
            border: none;
            font-size: 13px;
        }

        .dropdown-item:focus { outline: none; background: rgba(99,102,241,0.06); }

        .dropdown-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .dropdown-item:hover {
            background: rgba(99, 102, 241, 0.08);
            color: #4f46e5;
            transform: translateX(2px);
        }

        .dropdown-item:hover::before {
            opacity: 1;
        }

        .dropdown-item.active {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            color: white;
            box-shadow: 
                0 2px 8px rgba(79, 70, 229, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .dropdown-item.active:hover {
            background: linear-gradient(135deg, #4338ca 0%, #5b21b6 100%);
            transform: translateX(0);
        }

        /* Item Icons */
        .item-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            position: relative;
        }

        /* Point type icons */
        .item-icon.crest-main {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
        }

        .item-icon.crest-local {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.2);
        }

        .item-icon.base-main {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .item-icon.base-local {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
        }

        .item-icon.structure {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
        }

        /* Segment class icons */
        .item-icon.non-significant {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }

        .item-icon.significant {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
        }

        .item-icon.excluded {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.2);
        }

        /* Action Button (Clear) */
        .action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border: none;
            border-radius: 8px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            color: #64748b;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }

        .action-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .action-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.15);
        }

        .action-btn:hover::before {
            opacity: 1;
        }

        /* Tool icons sizing */
        .tool-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        /* Advanced Chart Interaction Toolbar */
        .chart-tools {
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            backdrop-filter: blur(12px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 12px 16px;
            margin: 8px 0 12px 0;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 2px 8px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            position: relative;
            z-index: 60;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        
        .chart-tools:hover {
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.15),
                0 4px 12px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
        }
        
        .chart-tools::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.03) 0%, rgba(139, 92, 246, 0.03) 100%);
            pointer-events: none;
        }

        /* Tool Groups */
        .tool-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 8px;
            background: rgba(248, 250, 252, 0.7);
            border: 1px solid rgba(226, 232, 240, 0.5);
            border-radius: 12px;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .tool-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s ease;
        }

        .tool-group:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(203, 213, 225, 0.8);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .tool-group:hover::before {
            left: 100%;
        }

        .tool-group-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 4px;
            transition: color 0.2s ease;
        }

        .tool-group:hover .tool-group-label {
            color: #475569;
        }

        /* Enhanced Tool Buttons */
        .tool-btn {
            position: relative;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 0.875rem;
            font-weight: 500;
            border: 1px solid transparent;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            color: #475569;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 6px;
            overflow: hidden;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .tool-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(99, 102, 241, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tool-btn:hover {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-color: rgba(99, 102, 241, 0.2);
            color: #334155;
            transform: translateY(-2px);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.1),
                0 1px 3px rgba(0, 0, 0, 0.06),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }

        .tool-btn:hover::before {
            opacity: 1;
        }

        .tool-btn:active {
            transform: translateY(-1px);
            transition-duration: 0.1s;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border-color: rgba(99, 102, 241, 0.5);
            color: #ffffff;
            box-shadow: 
                0 4px 12px rgba(99, 102, 241, 0.3),
                0 2px 6px rgba(139, 92, 246, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .tool-btn.active::before {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            opacity: 1;
        }

        .tool-btn.pending {
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            color: #ffffff;
            animation: pendingPulse 2s ease-in-out infinite;
            box-shadow: 
                0 4px 12px rgba(245, 158, 11, 0.3),
                0 2px 6px rgba(249, 115, 22, 0.2);
        }

        @keyframes pendingPulse {
            0%, 100% { 
                box-shadow: 
                    0 4px 12px rgba(245, 158, 11, 0.3),
                    0 2px 6px rgba(249, 115, 22, 0.2);
            }
            50% { 
                box-shadow: 
                    0 6px 16px rgba(245, 158, 11, 0.4),
                    0 3px 8px rgba(249, 115, 22, 0.3);
                transform: translateY(-3px);
            }
        }

        /* Tool Icons */
        .tool-icon {
            width: 16px;
            height: 16px;
            transition: transform 0.2s ease;
        }

        .tool-btn:hover .tool-icon {
            transform: scale(1.1);
        }

        .tool-btn.active .tool-icon {
            transform: scale(1.05);
        }

        /* Enhanced Dropdowns */
        .tool-select {
            padding: 6px 10px;
            border: 1px solid rgba(203, 213, 225, 0.6);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            font-size: 0.8rem;
            font-weight: 500;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 6px center;
            background-repeat: no-repeat;
            background-size: 14px;
            padding-right: 28px;
        }

        .tool-select:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(99, 102, 241, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236366f1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        }

        .tool-select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        /* Visibility Toggle */
        .chart-anno-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(248, 250, 252, 0.7);
            border: 1px solid rgba(226, 232, 240, 0.5);
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 500;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }

        .chart-anno-toggle:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(203, 213, 225, 0.8);
            color: #475569;
            transform: translateY(-1px);
        }

        .chart-anno-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            border: 2px solid #cbd5e1;
            border-radius: 4px;
            background: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            position: relative;
        }

        .chart-anno-toggle input[type="checkbox"]:checked {
            background: #6366f1;
            border-color: #6366f1;
        }

        .chart-anno-toggle input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
        }

        /* Dividers */
        .tool-divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(to bottom, transparent 0%, rgba(203, 213, 225, 0.5) 20%, rgba(203, 213, 225, 0.5) 80%, transparent 100%);
            margin: 0 4px;
        }

        /* Enhanced Annotations List */
        .chart-annotations-list {
            margin-top: 12px;
            padding: 12px;
            background: rgba(248, 250, 252, 0.5);
            border: 1px solid rgba(226, 232, 240, 0.6);
            border-radius: 12px;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
        }

        .chart-annotations-list:empty {
            display: none;
        }

        .chart-annotations-list:not(:empty) {
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .anno-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(226, 232, 240, 0.6);
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            position: relative;
            overflow: hidden;
            animation: slideInUp 0.3s ease-out forwards;
        }

        .anno-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.05), transparent);
            transition: left 0.5s ease;
        }

        .anno-item:hover {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(99, 102, 241, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .anno-item:hover::before {
            left: 100%;
        }

        .anno-item:last-child {
            margin-bottom: 0;
        }

        /* Enhanced Annotation Components */
        .anno-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            color: white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            flex-shrink: 0;
            transition: transform 0.2s ease;
        }

        .anno-item:hover .anno-icon {
            transform: scale(1.05);
        }

        .anno-content {
            flex: 1;
            min-width: 0;
        }

        .anno-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 4px;
            text-transform: capitalize;
        }

        .anno-coordinates {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.75rem;
            color: #64748b;
        }

        .anno-coordinates span {
            background: rgba(248, 250, 252, 0.8);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(226, 232, 240, 0.6);
        }

        .anno-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .anno-edit,
        .anno-delete {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid transparent;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            background: rgba(248, 250, 252, 0.8);
            color: #64748b;
        }

        .anno-edit:hover {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(99, 102, 241, 0.3);
        }

        .anno-delete:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(220, 38, 38, 0.3);
        }

        /* Inline Editing Styles */
        .anno-item.editing {
            background: rgba(59,130,246,0.08);
            border-color: #3b82f6;
            transform: scale(1.02);
        }

        .anno-item.editing .anno-actions {
            opacity: 1;
        }

        .anno-edit-form {
            display: none;
            grid-template-columns: 1fr auto;
            gap: 8px;
            padding: 8px;
            background: rgba(248,250,252,0.95);
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-top: 6px;
        }

        .anno-item.editing .anno-edit-form {
            display: grid;
        }

        .anno-item.editing .anno-content {
            display: none;
        }

        .anno-edit-inputs {
            display: grid;
            gap: 6px;
        }

        .anno-edit-input {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s ease;
            background: white;
        }

        .anno-edit-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59,130,246,0.1);
        }

        .anno-edit-input.error {
            border-color: #ef4444;
            background: rgba(239,68,68,0.05);
        }

        .anno-edit-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .anno-save-btn,
        .anno-cancel-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s ease;
            min-width: 60px;
        }

        .anno-save-btn {
            background: #16a34a;
            color: white;
        }

        .anno-save-btn:hover {
            background: #15803d;
            transform: translateY(-1px);
        }

        .anno-save-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .anno-cancel-btn {
            background: #f1f5f9;
            color: #475569;
            border: 1px solid #e2e8f0;
        }

        .anno-cancel-btn:hover {
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .anno-validation-error {
            color: #ef4444;
            font-size: 10px;
            margin-top: 2px;
            display: none;
        }

        .anno-edit-input.error + .anno-validation-error {
            display: block;
        }

        /* Point-specific styling */
        .anno-point {
            border-left: 4px solid #6366f1;
        }

        .anno-point:hover {
            border-left-color: #4f46e5;
        }

        /* Segment-specific styling */
        .anno-segment {
            border-left: 4px solid #16a34a;
        }

        .anno-segment:hover {
            border-left-color: #15803d;
        }

        .anno-segment .range {
            color: #059669;
            font-weight: 500;
        }

        .anno-segment .length {
            color: #0d9488;
            font-weight: 600;
        }

        /* Legacy annotation meta for backwards compatibility */
        .anno-meta {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.8rem;
            color: #64748b;
            flex: 1;
            transition: color 0.2s ease;
        }

        /* Interactive Chart Feedback & Overlays */
        .chart-container {
            position: relative;
            height: 300px;
            z-index: 1;
            overflow: hidden;
            border-radius: 12px;
        }

        .chart-container.tool-active {
            cursor: crosshair;
        }

        .chart-container.tool-point-active {
            cursor: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3e%3ccircle cx='12' cy='12' r='3' fill='%236366f1'/%3e%3cpath d='M12 1v6m0 6v6m11-7h-6m-6 0H1' stroke='%236366f1' stroke-width='2'/%3e%3c/svg%3e") 12 12, crosshair;
        }

        .chart-container.tool-segment-active {
            cursor: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3e%3cpath d='M8 12h8m-8 0V8m0 4v4m8-4V8m0 4v4' stroke='%236366f1' stroke-width='2' fill='none'/%3e%3c/svg%3e") 12 12, crosshair;
        }

        .chart-container.tool-segment-pending {
            cursor: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3e%3cpath d='M8 12h8m-8 0V8m0 4v4m8-4V8m0 4v4' stroke='%23f59e0b' stroke-width='2' fill='none'/%3e%3c/svg%3e") 12 12, crosshair;
        }

        /* Chart Overlay for Interactive Elements */
        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* Chart R/D Selector - repositioned below chart title */
        .chart-rd-selector-inline {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 8px 0 4px 0;
            font-size: 0.75rem;
            color: #64748b;
            gap: 4px;
        }

        .chart-rd-selector-inline .view-label {
            font-weight: 500;
            margin-right: 6px;
        }

        .chart-rd-selector-inline .chart-view-toggle-btn {
            background: rgba(248, 250, 252, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.7rem;
            font-weight: 600;
            color: #64748b;
            transition: all 0.15s cubic-bezier(0.2, 0.8, 0.2, 1);
            cursor: pointer;
        }

        .chart-rd-selector-inline .chart-view-toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
            border-right: none;
        }

        .chart-rd-selector-inline .chart-view-toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
        }

        .chart-rd-selector-inline .chart-view-toggle-btn:only-child {
            border-radius: 4px;
        }

        .chart-rd-selector-inline .chart-view-toggle-btn:hover {
            background: rgba(226, 232, 240, 0.8);
            color: #475569;
        }

        .chart-rd-selector-inline .chart-view-toggle-btn.active {
            background: #6366f1;
            border-color: #6366f1;
            color: white;
        }

        .chart-rd-selector-inline .chart-view-toggle-btn.active:hover {
            background: #5856eb;
        }

        /* Legacy chart R/D selector - kept for backward compatibility */
        .chart-rd-selector {
            position: absolute;
            top: 12px;
            left: 12px;
            display: flex;
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
            z-index: 15;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .chart-view-toggle-btn {
            background: none;
            border: none;
            padding: 8px 12px;
            font-size: 0.875rem;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            border-radius: 6px;
            min-width: 36px;
            text-align: center;
        }

        .chart-view-toggle-btn:first-child {
            border-radius: 6px 0 0 6px;
        }

        .chart-view-toggle-btn:last-child {
            border-radius: 0 6px 6px 0;
        }

        .chart-view-toggle-btn:only-child {
            border-radius: 6px;
        }

        .chart-view-toggle-btn:hover {
            background: rgba(99, 102, 241, 0.1);
            color: #6366f1;
        }

        .chart-view-toggle-btn.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.2);
        }

        .chart-view-toggle-btn.active:hover {
            background: linear-gradient(135deg, #5b59f7 0%, #8352f0 100%);
        }

        .chart-crosshair {
            position: absolute;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .chart-crosshair.visible {
            opacity: 0.6;
        }

        .chart-crosshair-line {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            position: absolute;
        }

        .chart-crosshair-vertical {
            width: 2px;
            height: 100%;
            box-shadow: 0 0 4px rgba(99, 102, 241, 0.4);
        }

        .chart-crosshair-horizontal {
            height: 2px;
            width: 100%;
            box-shadow: 0 0 4px rgba(99, 102, 241, 0.4);
        }

        /* Preview Point */
        .chart-preview-point {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 
                0 4px 12px rgba(99, 102, 241, 0.4),
                0 0 0 4px rgba(99, 102, 241, 0.1);
            transform: translate(-50%, -50%) scale(0);
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            z-index: 15;
        }

        .chart-preview-point.visible {
            transform: translate(-50%, -50%) scale(1);
        }

        .chart-preview-point.pulse {
            animation: previewPointPulse 1.5s ease-in-out infinite;
        }

        @keyframes previewPointPulse {
            0%, 100% {
                box-shadow: 
                    0 4px 12px rgba(99, 102, 241, 0.4),
                    0 0 0 4px rgba(99, 102, 241, 0.1);
            }
            50% {
                box-shadow: 
                    0 6px 16px rgba(99, 102, 241, 0.6),
                    0 0 0 8px rgba(99, 102, 241, 0.2);
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        /* Preview Segment */
        .chart-preview-segment {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #f59e0b 0%, #f97316 100%);
            border-radius: 2px;
            box-shadow: 
                0 2px 8px rgba(245, 158, 11, 0.4),
                0 0 0 2px rgba(245, 158, 11, 0.1);
            transform: scaleX(0);
            transform-origin: left center;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            z-index: 12;
        }

        .chart-preview-segment.visible {
            transform: scaleX(1);
        }

        .chart-preview-segment::before,
        .chart-preview-segment::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #f59e0b;
            border: 2px solid rgba(255, 255, 255, 0.9);
            top: 50%;
            transform: translateY(-50%);
        }

        .chart-preview-segment::before {
            left: -6px;
        }

        .chart-preview-segment::after {
            right: -6px;
        }

        /* Coordinate Display */
        .chart-coordinates {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border-radius: 8px;
            color: white;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.75rem;
            font-weight: 500;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            z-index: 20;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-coordinates.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .chart-coordinates::before {
            content: '';
            position: absolute;
            bottom: -4px;
            right: 16px;
            width: 8px;
            height: 8px;
            background: rgba(0, 0, 0, 0.8);
            transform: rotate(45deg);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Tool Status Indicator */
        .chart-tool-status {
            position: absolute;
            top: 12px;
            left: 12px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(226, 232, 240, 0.6);
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 600;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chart-tool-status.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .chart-tool-status.mode-point {
            color: #6366f1;
            border-color: rgba(99, 102, 241, 0.3);
        }

        .chart-tool-status.mode-segment {
            color: #f59e0b;
            border-color: rgba(245, 158, 11, 0.3);
        }

        .chart-tool-status.mode-segment.pending {
            animation: statusPending 2s ease-in-out infinite;
        }

        @keyframes statusPending {
            0%, 100% {
                box-shadow: 0 2px 8px rgba(245, 158, 11, 0.2);
            }
            50% {
                box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
            }
        }

        .tool-status-icon {
            width: 12px;
            height: 12px;
        }

        /* Enhanced Canvas Hover Effects */
        .chart-container canvas {
            transition: all 0.2s ease;
            border-radius: 8px;
        }

        .chart-container.tool-active canvas {
            box-shadow: inset 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        .chart-container.tool-active:hover canvas {
            box-shadow: inset 0 0 0 2px rgba(99, 102, 241, 0.4);
        }

        /* Measurement Lines & Guides */
        .chart-measurement-line {
            position: absolute;
            background: rgba(99, 102, 241, 0.3);
            pointer-events: none;
            z-index: 8;
        }

        .chart-measurement-vertical {
            width: 1px;
            height: 100%;
        }

        .chart-measurement-horizontal {
            height: 1px;
            width: 100%;
        }

        .chart-measurement-label {
            position: absolute;
            padding: 2px 6px;
            background: rgba(99, 102, 241, 0.9);
            color: white;
            font-size: 0.7rem;
            font-weight: 500;
            border-radius: 4px;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            margin-top: -4px;
        }

        /* Snap Guidelines */
        .chart-snap-guide {
            position: absolute;
            background: rgba(34, 197, 94, 0.6);
            pointer-events: none;
            z-index: 9;
            animation: snapGuideFlash 0.3s ease-out;
        }

        .chart-snap-guide-vertical {
            width: 2px;
            height: 100%;
        }

        .chart-snap-guide-horizontal {
            height: 2px;
            width: 100%;
        }

        @keyframes snapGuideFlash {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1.1);
            }
            100% {
                opacity: 0.6;
                transform: scale(1);
            }
        }

        /* Feedback Animation Keyframes */
        @keyframes pointAddedPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes segmentStartPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes segmentCompleteOut {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }

        @keyframes segmentCompleteFlash {
            0% {
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        /* ========================================================================= */
        /* FLOATING CHART TOOLS PALETTE - Sophisticated Interactive Design */
        /* ========================================================================= */
        
        .floating-tools-palette {
            position: fixed;
            top: 80px;
            right: 30px;
            width: 280px;
            max-height: 85vh;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            z-index: 10000;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            overflow: hidden;
        }

        .floating-tools-palette.hidden {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            pointer-events: none;
        }

        .floating-tools-palette.minimized {
            height: 48px;
            overflow: hidden;
            cursor: pointer;
        }

        .floating-tools-palette.minimized .palette-body,
        .floating-tools-palette.minimized .palette-drag-handle {
            opacity: 0;
            pointer-events: none;
        }

        .floating-tools-palette:hover {
            box-shadow: 
                0 25px 30px -5px rgba(0, 0, 0, 0.15),
                0 15px 15px -5px rgba(0, 0, 0, 0.08),
                0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        /* Palette Header */
        .palette-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            border-radius: 16px 16px 0 0;
            position: relative;
            overflow: hidden;
        }

        .palette-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.8s ease;
        }

        .floating-tools-palette:hover .palette-header::before {
            left: 100%;
        }

        .palette-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 0.875rem;
        }

        .palette-icon {
            width: 18px;
            height: 18px;
            stroke-width: 2;
        }

        .palette-controls {
            display: flex;
            gap: 4px;
        }

        .palette-control-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .palette-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .palette-control-btn svg {
            width: 14px;
            height: 14px;
            stroke-width: 2;
        }

        /* Palette Body */
        .palette-body {
            padding: 16px;
            max-height: calc(85vh - 100px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .palette-body::-webkit-scrollbar {
            width: 6px;
        }

        .palette-body::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        .palette-body::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .palette-body::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Tool Sections */
        .tool-section {
            margin-bottom: 20px;
            background: rgba(248, 250, 252, 0.5);
            border: 1px solid #f1f5f9;
            border-radius: 12px;
            padding: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .tool-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.02), transparent);
            transition: left 0.6s ease;
        }

        .tool-section:hover {
            border-color: #e2e8f0;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }

        .tool-section:hover::before {
            left: 100%;
        }

        .tool-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-weight: 600;
            color: #374151;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .section-icon {
            width: 16px;
            height: 16px;
            stroke-width: 2;
            color: #6366f1;
        }

        /* Tool Mode Selection */
        .tool-mode-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
        }

        .tool-mode-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 12px 8px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .tool-mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tool-mode-btn svg,
        .tool-mode-btn span {
            position: relative;
            z-index: 1;
            transition: all 0.2s ease;
        }

        .tool-mode-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2;
            color: #6b7280;
        }

        .tool-mode-btn span {
            font-size: 0.75rem;
            font-weight: 500;
            color: #374151;
        }

        .tool-mode-btn:hover {
            border-color: #6366f1;
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px rgba(99, 102, 241, 0.2);
        }

        .tool-mode-btn.active {
            border-color: #6366f1;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
        }

        .tool-mode-btn.active::before {
            opacity: 1;
        }

        .tool-mode-btn.active svg,
        .tool-mode-btn.active span {
            color: white;
        }

        /* Tool Configuration Grid */
        .tool-config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .tool-config-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: left;
        }

        .tool-config-btn:hover {
            border-color: #6366f1;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(99, 102, 241, 0.1);
        }

        .tool-config-btn.active {
            border-color: #6366f1;
            background: linear-gradient(135deg, #eef2ff, #e0e7ff);
        }

        .tool-config-btn span {
            font-size: 0.75rem;
            font-weight: 500;
            color: #374151;
            line-height: 1.2;
        }

        .tool-config-btn.active span {
            color: #3730a3;
            font-weight: 600;
        }

        /* Configuration Icons */
        .config-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .config-icon.crest-main { background: #ef4444; }
        .config-icon.crest-local { background: #f97316; }
        .config-icon.base-main { background: #06b6d4; }
        .config-icon.base-local { background: #3b82f6; }
        .config-icon.structure { background: #8b5cf6; }
        .config-icon.non-significant { background: #10b981; }
        .config-icon.significant { background: #f59e0b; }
        .config-icon.excluded { background: #6b7280; }

        /* Global Tools */
        .global-tools-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .global-tool-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .global-tool-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.05), transparent);
            transition: left 0.5s ease;
        }

        .global-tool-btn:hover {
            border-color: #6366f1;
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px rgba(99, 102, 241, 0.15);
        }

        .global-tool-btn:hover::before {
            left: 100%;
        }

        .global-tool-btn svg {
            width: 18px;
            height: 18px;
            stroke-width: 2;
            color: #6b7280;
            transition: color 0.2s ease;
        }

        .global-tool-btn span {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            flex: 1;
        }

        .global-tool-btn.active {
            border-color: #10b981;
            background: linear-gradient(135deg, #ecfdf5, #d1fae5);
        }

        .global-tool-btn.active svg {
            color: #059669;
        }

        .global-tool-btn.active span {
            color: #047857;
            font-weight: 600;
        }

        /* Tool Status Indicator */
        .tool-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #d1d5db;
            transition: all 0.2s ease;
        }

        .global-tool-btn.active .tool-status-indicator {
            background: #10b981;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }

        /* Active Chart Display */
        .active-chart-display {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .chart-indicator {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .chart-azimuth {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
        }

        .chart-highlight-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #d1d5db;
            transition: all 0.3s ease;
        }

        .chart-highlight-indicator.active {
            background: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
            animation: chartPulse 2s infinite;
        }

        @keyframes chartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .chart-instructions {
            font-size: 0.75rem;
            color: #6b7280;
            font-style: italic;
        }

        /* Drag Handle */
        .palette-drag-handle {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 24px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 0 0 16px 16px;
            cursor: grab;
            transition: all 0.2s ease;
        }

        .palette-drag-handle:active {
            cursor: grabbing;
        }

        .palette-drag-handle:hover {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
        }

        .drag-dots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
        }

        .drag-dot {
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: #cbd5e1;
            transition: background 0.2s ease;
        }

        .palette-drag-handle:hover .drag-dot {
            background: #94a3b8;
        }

        /* Section Visibility States */
        .tool-section.point-tools,
        .tool-section.segment-tools {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tool-section.point-tools.hidden,
        .tool-section.segment-tools.hidden {
            opacity: 0.3;
            transform: scale(0.98);
            pointer-events: none;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .floating-tools-palette {
                width: 260px;
                right: 15px;
                top: 60px;
            }
            
            .tool-mode-group {
                grid-template-columns: 1fr;
                gap: 4px;
            }
            
            .tool-mode-btn {
                flex-direction: row;
                justify-content: flex-start;
                padding: 10px 12px;
            }
        }

        /* Animation Classes */
        .floating-tools-palette.entering {
            animation: paletteEnter 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .floating-tools-palette.leaving {
            animation: paletteLeave 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes paletteEnter {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes paletteLeave {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        /* Chart Targeting Visual Feedback */
        .chart-container.chart-targeted {
            position: relative;
            overflow: visible;
        }

        .chart-container.chart-targeted::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 3px solid #6366f1;
            border-radius: 12px;
            animation: chartTargetPulse 1s ease-out;
            pointer-events: none;
            z-index: 1;
        }

        .chart-container.chart-targeted::after {
            content: 'TARGETED';
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            font-size: 0.65rem;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            animation: chartTargetLabel 2s ease-out;
            pointer-events: none;
            z-index: 2;
        }

        @keyframes chartTargetPulse {
            0% {
                border-color: #6366f1;
                transform: scale(1);
            }
            50% {
                border-color: #8b5cf6;
                transform: scale(1.02);
            }
            100% {
                border-color: #6366f1;
                transform: scale(1);
            }
        }

        @keyframes chartTargetLabel {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(10px);
            }
            20% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            80% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.9) translateY(-5px);
            }
        }

        /* Floating Tool Palette Keyboard Shortcuts Help */
        .floating-tools-palette .palette-body::after {
            content: 'Shortcuts: Ctrl+T (toggle), 1-3 (modes), V (visibility), Shift+C (clear)';
            display: block;
            font-size: 0.6rem;
            color: #9ca3af;
            text-align: center;
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #f1f5f9;
            font-style: italic;
        }

        /* Floating Tools Notice */
        .floating-tools-notice {
            background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
            border: 2px solid #c7d2fe;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            position: relative;
            overflow: hidden;
        }

        .floating-tools-notice::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.1), transparent);
            transition: left 0.8s ease;
        }

        .floating-tools-notice:hover::before {
            left: 100%;
        }

        .notice-content {
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            z-index: 1;
        }

        .notice-icon {
            width: 24px;
            height: 24px;
            stroke-width: 2;
            color: #6366f1;
            flex-shrink: 0;
        }

        .notice-text {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .notice-text strong {
            font-size: 0.875rem;
            font-weight: 600;
            color: #3730a3;
        }

        .notice-text span {
            font-size: 0.75rem;
            color: #4f46e5;
            line-height: 1.3;
        }

        .notice-activate {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
        }

        .notice-activate:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px rgba(99, 102, 241, 0.3);
        }

        .notice-activate:active {
            transform: translateY(0);
        }

        /* Chart area styling - clean without notice elements */
        
        /* Subtle hover hint for chart tools access */
        .chart-container {
            position: relative;
        }
        
        .chart-hover-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
            white-space: nowrap;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .chart-hover-hint::before {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 4px solid rgba(15, 23, 42, 0.9);
        }
        
        .chart-container:hover .chart-hover-hint.delayed-show {
            opacity: 1;
        }

        /* ========================================================================= */
        /* FLOATING ANNOTATION EDITOR - Sophisticated Interactive Window */
        /* ========================================================================= */
        
        .floating-annotation-editor {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 420px;
            max-height: calc(100vh - 140px);
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            backdrop-filter: blur(8px);
            overflow: hidden;
        }

        .floating-annotation-editor.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .floating-annotation-editor.minimized {
            transform: translateY(-10px) scale(0.9);
            max-height: 60px;
            overflow: hidden;
        }

        .floating-annotation-editor:hover {
            box-shadow: 0 25px 30px -5px rgba(0, 0, 0, 0.12), 0 12px 15px -5px rgba(0, 0, 0, 0.06);
        }

        /* Editor Header */
        .annotation-editor-header {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-bottom: 1px solid #e2e8f0;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: move;
            user-select: none;
            position: relative;
        }

        .annotation-editor-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #6366f1, #8b5cf6, #06b6d4);
        }

        .annotation-editor-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 0.875rem;
            color: #374151;
        }

        .annotation-type-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 8px;
        }

        .annotation-editor-controls {
            display: flex;
            gap: 8px;
        }

        .annotation-editor-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(148, 163, 184, 0.1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: #64748b;
        }

        .annotation-editor-btn:hover {
            background: rgba(148, 163, 184, 0.2);
            color: #475569;
            transform: translateY(-1px);
        }

        .annotation-editor-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Editor Body */
        .annotation-editor-body {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 transparent;
        }

        .annotation-editor-body::-webkit-scrollbar {
            width: 6px;
        }

        .annotation-editor-body::-webkit-scrollbar-track {
            background: transparent;
        }

        .annotation-editor-body::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .annotation-editor-body::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Editor Sections */
        .annotation-section {
            border-bottom: 1px solid #f1f5f9;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .annotation-section:last-child {
            border-bottom: none;
        }

        .annotation-section-header {
            padding: 16px 20px;
            background: #fafbfc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .annotation-section-header::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: transparent;
            transition: background 0.2s ease-out;
        }

        .annotation-section-header:hover {
            background: #f1f5f9;
        }

        .annotation-section-header:hover::before {
            background: #6366f1;
        }

        .annotation-section-title {
            font-weight: 600;
            font-size: 0.875rem;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .annotation-section-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: rotate(0deg);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #64748b;
        }

        .annotation-section-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .annotation-section-content {
            padding: 20px;
            max-height: 1000px;
            opacity: 1;
            overflow: hidden;
            transition: all 0.45s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .annotation-section-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
        }

        /* Edit Form Styles */
        .annotation-edit-form {
            display: grid;
            gap: 16px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-group-inline {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .form-label {
            font-weight: 500;
            font-size: 0.875rem;
            color: #374151;
        }

        .form-input,
        .form-select {
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: #ffffff;
            font-size: 0.875rem;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .form-input:hover,
        .form-select:hover {
            border-color: #9ca3af;
        }

        .form-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 8px;
        }

        .form-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .form-btn-primary {
            background: #6366f1;
            color: white;
        }

        .form-btn-primary:hover {
            background: #5855eb;
            transform: translateY(-1px);
        }

        .form-btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .form-btn-secondary:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .form-btn-danger {
            background: #ef4444;
            color: white;
        }

        .form-btn-danger:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        /* Calculations Display */
        .calculation-grid {
            display: grid;
            gap: 12px;
        }

        .calculation-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .calculation-item:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
            transform: translateY(-1px);
        }

        .calculation-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        .calculation-value {
            font-size: 0.875rem;
            font-weight: 600;
            color: #1e293b;
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .calculation-unit {
            font-size: 0.75rem;
            font-weight: 400;
            color: #64748b;
        }

        /* Subsection Styling */
        .calculation-subsection {
            margin: 16px 0;
        }

        .calculation-subsection:first-child {
            margin-top: 0;
        }

        .calculation-subsection:last-child {
            margin-bottom: 0;
        }

        .subsection-title {
            font-weight: 600;
            font-size: 0.8125rem;
            color: #475569;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e2e8f0;
        }

        /* Point-specific calculations */
        .point-calculations .calculation-item {
            background: linear-gradient(135deg, #fef3c7 0%, #fef9e7 100%);
            border-color: #f59e0b;
        }

        /* Segment-specific calculations */
        .segment-calculations .calculation-item {
            background: linear-gradient(135deg, #dbeafe 0%, #f0f9ff 100%);
            border-color: #3b82f6;
        }

        /* Status indicators */
        .calculation-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .calculation-status.valid {
            background: #dcfce7;
            color: #166534;
        }

        .calculation-status.warning {
            background: #fef3c7;
            color: #92400e;
        }

        .calculation-status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        /* Drag handle styling */
        .annotation-editor-drag-handle {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 32px;
            height: 4px;
            background: #d1d5db;
            border-radius: 2px;
            cursor: move;
            transition: background 0.2s ease-out;
        }

        .annotation-editor-drag-handle:hover {
            background: #9ca3af;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .floating-annotation-editor {
                width: calc(100vw - 40px);
                left: 20px;
                right: 20px;
                max-height: calc(100vh - 120px);
            }
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <!-- ========================================================================= -->
    <!-- FLOATING CHART TOOLS PALETTE - Always On Top Interactive Window -->
    <!-- ========================================================================= -->
    <div id="floating-tools-palette" class="floating-tools-palette hidden">
        <div class="palette-header">
            <div class="palette-title">
                <svg class="palette-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M3 3h18v18H3zM9 9h6v6H9z"/>
                    <path d="M9 3v6M15 3v6M21 9H15M21 15H15M9 21v-6M15 21v-6M3 9h6M3 15h6"/>
                </svg>
                Chart Tools
            </div>
            <div class="palette-controls">
                <button class="palette-control-btn palette-minimize" title="Minimize (Double right-click any chart to restore)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M6 12h12"/>
                    </svg>
                </button>
                <button class="palette-control-btn palette-close" title="Close Tools">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="palette-body">
            <!-- Tool Mode Selection -->
            <div class="tool-section">
                <div class="tool-section-header">
                    <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M12 1v6M12 17v6M4.22 4.22l4.24 4.24M15.54 15.54l4.24 4.24M1 12h6M17 12h6M4.22 19.78l4.24-4.24M15.54 8.46l4.24-4.24"/>
                    </svg>
                    Mode
                </div>
                <div class="tool-mode-group">
                    <button class="tool-mode-btn" data-mode="none" title="Selection Mode (No Tool Active)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                        </svg>
                        <span>Select</span>
                    </button>
                    <button class="tool-mode-btn" data-mode="point" title="Point Annotation Mode">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="12" cy="12" r="4"/>
                        </svg>
                        <span>Point</span>
                    </button>
                    <button class="tool-mode-btn" data-mode="segment" title="Segment Annotation Mode">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M5 12h14"/>
                            <circle cx="5" cy="12" r="2"/>
                            <circle cx="19" cy="12" r="2"/>
                        </svg>
                        <span>Segment</span>
                    </button>
                </div>
            </div>

            <!-- Point Tool Configuration -->
            <div class="tool-section point-tools">
                <div class="tool-section-header">
                    <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <circle cx="12" cy="12" r="4"/>
                        <circle cx="12" cy="12" r="1"/>
                    </svg>
                    Point Type
                </div>
                <div class="tool-config-grid">
                    <button class="tool-config-btn" data-point-type="crest-main" title="Main Crest Point">
                        <div class="config-icon crest-main"></div>
                        <span>Main Crest</span>
                    </button>
                    <button class="tool-config-btn" data-point-type="crest-local" title="Local Crest Point">
                        <div class="config-icon crest-local"></div>
                        <span>Local Crest</span>
                    </button>
                    <button class="tool-config-btn" data-point-type="base-main" title="Main Base Point">
                        <div class="config-icon base-main"></div>
                        <span>Main Base</span>
                    </button>
                    <button class="tool-config-btn" data-point-type="base-local" title="Local Base Point">
                        <div class="config-icon base-local"></div>
                        <span>Local Base</span>
                    </button>
                    <button class="tool-config-btn" data-point-type="structure" title="Structure Point">
                        <div class="config-icon structure"></div>
                        <span>Structure</span>
                    </button>
                </div>
            </div>

            <!-- Segment Tool Configuration -->
            <div class="tool-section segment-tools">
                <div class="tool-section-header">
                    <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M5 12h14"/>
                        <circle cx="5" cy="12" r="2"/>
                        <circle cx="19" cy="12" r="2"/>
                    </svg>
                    Segment Class
                </div>
                <div class="tool-config-grid">
                    <button class="tool-config-btn" data-segment-class="non-significant" title="Non-Significant Segment">
                        <div class="config-icon non-significant"></div>
                        <span>Non-Significant</span>
                    </button>
                    <button class="tool-config-btn" data-segment-class="significant" title="Significant Segment">
                        <div class="config-icon significant"></div>
                        <span>Significant</span>
                    </button>
                    <button class="tool-config-btn" data-segment-class="excluded" title="Excluded Segment">
                        <div class="config-icon excluded"></div>
                        <span>Excluded</span>
                    </button>
                </div>
            </div>

            <!-- Global Tools -->
            <div class="tool-section global-tools">
                <div class="tool-section-header">
                    <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                    Actions
                </div>
                <div class="global-tools-grid">
                    <button class="global-tool-btn annotation-visibility-toggle" title="Toggle Annotation Visibility">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                        <span>Annotations</span>
                        <div class="tool-status-indicator"></div>
                    </button>
                    <button class="global-tool-btn clear-all-annotations" title="Clear All Annotations">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/>
                        </svg>
                        <span>Clear All</span>
                    </button>
                </div>
            </div>

            <!-- Active Chart Indicator -->
            <div class="tool-section active-chart">
                <div class="tool-section-header">
                    <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                        <circle cx="12" cy="12" r="4"/>
                    </svg>
                    Target
                </div>
                <div class="active-chart-display">
                    <div class="chart-indicator">
                        <span class="chart-azimuth">No chart selected</span>
                        <div class="chart-highlight-indicator"></div>
                    </div>
                    <div class="chart-instructions">
                        Click on any chart to target it
                    </div>
                </div>
            </div>
        </div>

        <!-- Drag Handle -->
        <div class="palette-drag-handle" title="Drag to move">
            <div class="drag-dots">
                <div class="drag-dot"></div>
                <div class="drag-dot"></div>
                <div class="drag-dot"></div>
                <div class="drag-dot"></div>
                <div class="drag-dot"></div>
                <div class="drag-dot"></div>
            </div>
        </div>
    </div>

    <!-- ========================================================================= -->
    <!-- FLOATING ANNOTATION EDITOR - Interactive Annotation Details Window -->
    <!-- ========================================================================= -->
    <div id="floating-annotation-editor" class="floating-annotation-editor">
        <div class="annotation-editor-header">
            <div class="annotation-editor-title">
                <div class="annotation-type-icon" id="annotation-type-icon"></div>
                <span id="annotation-title">Annotation Details</span>
            </div>
            <div class="annotation-editor-controls">
                <button class="annotation-editor-btn" id="minimize-annotation-editor" title="Minimize">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
                    </svg>
                </button>
                <button class="annotation-editor-btn" id="close-annotation-editor" title="Close">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="annotation-editor-body">
            <!-- Edit Section - Always Expanded by Default -->
            <div class="annotation-section">
                <div class="annotation-section-header" data-section="edit">
                    <div class="annotation-section-title">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                        </svg>
                        Edit Properties
                    </div>
                    <div class="annotation-section-toggle">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                    </div>
                </div>
                <div class="annotation-section-content" id="edit-section-content">
                    <div class="annotation-edit-form" id="annotation-edit-form">
                        <!-- Dynamic form content will be inserted here -->
                    </div>
                </div>
            </div>

            <!-- Basic Calculations Section -->
            <div class="annotation-section">
                <div class="annotation-section-header" data-section="basic-calculations">
                    <div class="annotation-section-title">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                        </svg>
                        Basic Calculations
                    </div>
                    <div class="annotation-section-toggle collapsed">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                    </div>
                </div>
                <div class="annotation-section-content collapsed" id="basic-calculations-content">
                    <div class="calculation-grid" id="basic-calculations-grid">
                        <!-- Dynamic calculation content will be inserted here -->
                    </div>
                </div>
            </div>

            <!-- Advanced Analysis Section -->
            <div class="annotation-section">
                <div class="annotation-section-header" data-section="advanced-analysis">
                    <div class="annotation-section-title">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                        </svg>
                        Advanced Analysis
                    </div>
                    <div class="annotation-section-toggle collapsed">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                    </div>
                </div>
                <div class="annotation-section-content collapsed" id="advanced-analysis-content">
                    <div class="calculation-grid" id="advanced-analysis-grid">
                        <!-- Dynamic advanced calculation content will be inserted here -->
                    </div>
                </div>
            </div>

            <!-- Point Details Section (for segments only) -->
            <div class="annotation-section" id="point-details-section" style="display: none;">
                <div class="annotation-section-header" data-section="point-details">
                    <div class="annotation-section-title">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                        </svg>
                        Point Analysis
                    </div>
                    <div class="annotation-section-toggle collapsed">
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                    </div>
                </div>
                <div class="annotation-section-content collapsed" id="point-details-content">
                    <div id="point-details-grid">
                        <!-- Dynamic point details will be inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="annotation-editor-drag-handle"></div>
    </div>

    <div class="max-w-7xl mx-auto">
        <!-- The parent application would typically provide a title and description. -->
        <!-- This component now starts directly with the controls. -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div id="manager-card-container" class="lg:col-span-2 mb-2"></div>
            <div id="controlling-case-container" class="lg:col-span-2 mb-2"></div>
            <div id="control-panel-container" class="lg:col-span-2 mb-4"></div>
            <div id="collapsed-bar-container" class="lg:col-span-2 mb-4"></div>
            <div id="card-container" class="lg:col-span-2 grid grid-cols-1 lg:grid-cols-2 gap-6"></div>
        </div>
    </div>

    <script type="module">
        // =================================================================================
        // ANIMATION SPEED CONTROL SYSTEM
        // =================================================================================
        
        function getAnimationDuration(baseDurationMs) {
            // 0 => instant, higher => slower
            if (state.animationSpeed === 0) return 0;
            return Math.max(50, baseDurationMs * state.animationSpeed);
        }
        
        function getAnimationDelay(baseDelayMs) {
            if (state.animationSpeed === 0) return 0;
            return Math.max(10, baseDelayMs * state.animationSpeed);
        }
        
        function setCSSAnimationSpeed(element, property, baseDuration) {
            const duration = getAnimationDuration(baseDuration);
            element.style.setProperty(property, `${duration}ms`);
        }
        
        function updateAnimationSpeed(value) {
            state.animationSpeed = parseFloat(value);
            updateAnimationCSSVariables();
            // Update the display value next to the slider
            const speedValueDisplay = document.querySelector('#control-animation-speed-slider')?.parentElement?.querySelector('.speed-value');
            if (speedValueDisplay) {
                speedValueDisplay.textContent = `${state.animationSpeed.toFixed(1)}x`;
            }
        }

        function updateAnimationCSSVariables() {
            const root = document.documentElement;
            const baseDuration = 300; // Base duration in milliseconds
            
            if (state.animationSpeed === 0) {
                // Instant animations
                root.style.setProperty('--card-transition-duration', '0ms');
                root.style.setProperty('--section-transition-duration', '0ms');
                root.style.setProperty('--fade-duration', '0ms');
                root.style.setProperty('--hover-duration', '0ms');
            } else {
                // Scaled animations
                const scale = state.animationSpeed;
                const cardDuration = baseDuration * scale;
                const sectionDuration = (baseDuration * 0.8) * scale;
                const fadeDuration = (baseDuration * 0.6) * scale;
                const hoverDuration = (baseDuration * 0.4) * scale;
                
                root.style.setProperty('--card-transition-duration', `${cardDuration}ms`);
                root.style.setProperty('--section-transition-duration', `${sectionDuration}ms`);
                root.style.setProperty('--fade-duration', `${fadeDuration}ms`);
                root.style.setProperty('--hover-duration', `${hoverDuration}ms`);
            }
        }

        // =================================================================================
        // SCRIPT SETUP & DATA SIMULATION
        // =================================================================================

        let chartInstances = {};
        let longPressTimer;

        const state = {
            units: {
                crestElev: 'ft', structElev: 'ft', L: 'ft', Top: 'ft',
                Mid: 'ft', Bottom: 'ft', distToMid: 'ft', H: 'ft',
                Lh: 'ft', x: 'ft', z: 'ft', profileDistance: 'ft', profileElevation: 'ft'
            },
            coordinateFormat: 'dd', // 'dd' or 'dms'
            mirrorSectionsLg: true, // Mirror section states on large screens
            animationSpeed: 3.0, // Animation speed multiplier (0x to 5x, default 3.0x)
            allCardsDocked: true, // Default all cards to docked state
            allCardsExpanded: false, // Default cards to collapsed state
            mirrorSections: false, // Mirror sections toggle
            profileView: 'radial', // 'radial' or 'diametral' view for elevation profiles
            sectionsVisible: {
                siteLocation: true,
                selectionSummary: true,
                kztParams: true,
                chart: true
            },
            // Chart annotations and tools
            annotationsByAzimuth: {
                // Add some test annotations for debugging
                0: {
                    points: [
                        { id: 1, type: 'crest-main', xFt: 1000, yFt: 150, label: 'Test Point 1' },
                        { id: 2, type: 'base-local', xFt: 2500, yFt: 120, label: 'Test Point 2' }
                    ],
                    segments: [
                        { id: 3, class: 'significant', x1Ft: 500, x2Ft: 1500, label: 'Test Segment 1' }
                    ],
                    visible: true
                },
                45: {
                    points: [
                        { id: 4, type: 'structure', xFt: 800, yFt: 140, label: 'Structure Point' }
                    ],
                    segments: [
                        { id: 5, class: 'non-significant', x1Ft: 1000, x2Ft: 2000, label: 'Test Segment 2' }
                    ],
                    visible: true
                }
            }, // { [az]: { points:[], segments:[], visible: true } }
            chartTool: { mode: 'none', activeAzimuth: null, pointType: 'crest-local', segmentClass: 'non-significant', pending: null },
            // Expandable view panel states
            viewPanels: {}, // { [azimuth]: boolean } - expansion state for each azimuth
            // Chart display modes
            chartDisplayModes: {} // { [azimuth]: 'filled' | 'line' } - display mode for each azimuth
        };

        // =================================================================================
        // FLOATING ANNOTATION EDITOR - State and Calculation Engine
        // =================================================================================
        
        let floatingAnnotationEditor = {
            isVisible: false,
            isMinimized: false,
            currentAnnotation: null,
            currentAzimuth: null,
            isDragging: false,
            dragOffset: { x: 0, y: 0 }
        };

        // Advanced calculation engine for annotations
        function calculateAnnotationProperties(annotation, azimuth, type) {
            const calculations = {};
            const anno = ensureAzAnnotations(azimuth);
            const chart = chartInstances[azimuth];
            
            if (!chart || !chart.data || !chart.data.datasets) {
                return calculations;
            }

            const profileData = chart.data.datasets[0]?.data || [];
            const distUnit = state.units.profileDistance;
            const elevUnit = state.units.profileElevation;

            if (type === 'point') {
                calculations.basic = calculatePointBasicProperties(annotation, profileData, distUnit, elevUnit);
                calculations.advanced = calculatePointAdvancedProperties(annotation, anno, azimuth, distUnit, elevUnit);
            } else if (type === 'segment') {
                calculations.basic = calculateSegmentBasicProperties(annotation, profileData, distUnit, elevUnit);
                calculations.advanced = calculateSegmentAdvancedProperties(annotation, anno, azimuth, distUnit, elevUnit);
                calculations.points = calculateSegmentPointAnalysis(annotation, profileData, distUnit, elevUnit);
            }

            return calculations;
        }

        function calculatePointBasicProperties(point, profileData, distUnit, elevUnit) {
            const xVal = ftToUnitX(point.xFt);
            const yVal = ftToUnitY(point.yFt);
            const interpolatedY = interpolateYFromProfile(profileData, xVal);
            
            return {
                coordinates: {
                    label: 'Coordinates',
                    value: `${xVal.toFixed(1)}, ${yVal.toFixed(1)}`,
                    unit: `${distUnit}, ${elevUnit}`
                },
                elevation: {
                    label: 'Elevation',
                    value: yVal.toFixed(1),
                    unit: elevUnit
                },
                profileElevation: {
                    label: 'Profile Elevation',
                    value: interpolatedY != null ? interpolatedY.toFixed(1) : 'N/A',
                    unit: elevUnit
                },
                elevationDelta: {
                    label: 'Elevation Delta',
                    value: interpolatedY != null ? (yVal - interpolatedY).toFixed(1) : 'N/A',
                    unit: elevUnit,
                    status: interpolatedY != null ? (Math.abs(yVal - interpolatedY) < 0.1 ? 'valid' : 'warning') : 'error'
                }
            };
        }

        function calculatePointAdvancedProperties(point, annotations, azimuth, distUnit, elevUnit) {
            const advanced = {};
            const xVal = ftToUnitX(point.xFt);
            const yVal = ftToUnitY(point.yFt);

            // Find reference points
            const crestMain = annotations.points.find(p => p.type === 'crest-main');
            const baseMain = annotations.points.find(p => p.type === 'base-main');
            const structure = annotations.points.find(p => p.type === 'structure');

            if (crestMain) {
                const crestX = ftToUnitX(crestMain.xFt);
                const crestY = ftToUnitY(crestMain.yFt);
                advanced.distanceToCrest = {
                    label: 'Distance to Crest',
                    value: Math.abs(xVal - crestX).toFixed(1),
                    unit: distUnit
                };
                advanced.elevationDeltaToCrest = {
                    label: 'Elevation Delta to Crest',
                    value: (yVal - crestY).toFixed(1),
                    unit: elevUnit,
                    status: yVal > crestY ? 'warning' : 'valid'
                };
            }

            if (baseMain) {
                const baseX = ftToUnitX(baseMain.xFt);
                const baseY = ftToUnitY(baseMain.yFt);
                advanced.distanceToBase = {
                    label: 'Distance to Base',
                    value: Math.abs(xVal - baseX).toFixed(1),
                    unit: distUnit
                };
                advanced.elevationDeltaToBase = {
                    label: 'Elevation Delta to Base',
                    value: (yVal - baseY).toFixed(1),
                    unit: elevUnit
                };
            }

            if (structure) {
                const structX = ftToUnitX(structure.xFt);
                const structY = ftToUnitY(structure.yFt);
                advanced.distanceToStructure = {
                    label: 'Distance to Structure',
                    value: Math.abs(xVal - structX).toFixed(1),
                    unit: distUnit
                };
                advanced.elevationDeltaToStructure = {
                    label: 'Elevation Delta to Structure',
                    value: (yVal - structY).toFixed(1),
                    unit: elevUnit
                };
            }

            return advanced;
        }

        function calculateSegmentBasicProperties(segment, profileData, distUnit, elevUnit) {
            const x1 = ftToUnitX(segment.x1Ft);
            const x2 = ftToUnitX(segment.x2Ft);
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            const length = Math.abs(x2 - x1);

            // Calculate area under curve for this segment
            const area = calculateAreaUnderCurve(profileData, startX, endX);
            
            // Calculate average slope
            const startY = interpolateYFromProfile(profileData, startX);
            const endY = interpolateYFromProfile(profileData, endX);
            const avgSlope = length > 0 && startY !== null && endY !== null ? 
                ((endY - startY) / length) * 100 : null;

            return {
                range: {
                    label: 'Range',
                    value: `${startX.toFixed(1)} to ${endX.toFixed(1)}`,
                    unit: distUnit
                },
                length: {
                    label: 'Length',
                    value: length.toFixed(1),
                    unit: distUnit
                },
                startElevation: {
                    label: 'Start Elevation',
                    value: startY != null ? startY.toFixed(1) : 'N/A',
                    unit: elevUnit
                },
                endElevation: {
                    label: 'End Elevation',
                    value: endY != null ? endY.toFixed(1) : 'N/A',
                    unit: elevUnit
                },
                areaUnderCurve: {
                    label: 'Area Under Curve',
                    value: area != null ? area.toFixed(1) : 'N/A',
                    unit: `${distUnit}^2`
                },
                averageSlope: {
                    label: 'Average Slope',
                    value: avgSlope != null ? avgSlope.toFixed(2) : 'N/A',
                    unit: '%',
                    status: avgSlope != null ? (Math.abs(avgSlope) > 10 ? 'warning' : 'valid') : 'error'
                }
            };
        }

        function calculateSegmentAdvancedProperties(segment, annotations, azimuth, distUnit, elevUnit) {
            const advanced = {};
            const x1 = ftToUnitX(segment.x1Ft);
            const x2 = ftToUnitX(segment.x2Ft);
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);

            // Find overlapping segments
            const overlappingSegments = annotations.segments.filter(s => 
                s.id !== segment.id && segmentsOverlap(segment, s)
            );

            if (overlappingSegments.length > 0) {
                advanced.overlappingSegments = {
                    label: 'Overlapping Segments',
                    value: overlappingSegments.length.toString(),
                    unit: 'segments',
                    status: 'warning'
                };
            }

            // Calculate segment efficiency (area vs rectangle)
            const profileData = chartInstances[azimuth]?.data?.datasets[0]?.data || [];
            const area = calculateAreaUnderCurve(profileData, startX, endX);
            const startY = interpolateYFromProfile(profileData, startX);
            const endY = interpolateYFromProfile(profileData, endX);
            
            if (area != null && startY != null && endY != null) {
                const maxHeight = Math.max(Math.abs(startY), Math.abs(endY));
                const rectangularArea = (endX - startX) * maxHeight;
                const areaMagnitude = Math.abs(area);
                const efficiency = rectangularArea > 0 ? (areaMagnitude / rectangularArea) * 100 : 0;
                advanced.areaEfficiency = {
                    label: 'Area Efficiency',
                    value: efficiency.toFixed(1),
                    unit: '%',
                    status: efficiency > 80 ? 'valid' : efficiency > 60 ? 'warning' : 'error'
                };
            }

            return advanced;
        }

        function calculateSegmentPointAnalysis(segment, profileData, distUnit, elevUnit) {
            const x1 = ftToUnitX(segment.x1Ft);
            const x2 = ftToUnitX(segment.x2Ft);
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            const midX = (startX + endX) / 2;

            const startY = interpolateYFromProfile(profileData, startX);
            const midY = interpolateYFromProfile(profileData, midX);
            const endY = interpolateYFromProfile(profileData, endX);

            return {
                start: {
                    label: 'Start Point',
                    coordinates: `${startX.toFixed(1)}, ${startY != null ? startY.toFixed(1) : 'N/A'}`,
                    elevation: startY != null ? startY.toFixed(1) : 'N/A',
                    unit: elevUnit
                },
                middle: {
                    label: 'Mid Point',
                    coordinates: `${midX.toFixed(1)}, ${midY != null ? midY.toFixed(1) : 'N/A'}`,
                    elevation: midY != null ? midY.toFixed(1) : 'N/A',
                    unit: elevUnit
                },
                end: {
                    label: 'End Point',
                    coordinates: `${endX.toFixed(1)}, ${endY != null ? endY.toFixed(1) : 'N/A'}`,
                    elevation: endY != null ? endY.toFixed(1) : 'N/A',
                    unit: elevUnit
                }
            };
        }

        // Helper calculation functions
        function interpolateYFromProfile(profileData, xVal) {
            if (!profileData || profileData.length === 0) return null;
            
            for (let i = 1; i < profileData.length; i++) {
                const p0 = profileData[i - 1];
                const p1 = profileData[i];
                
                if ((xVal >= p0.x && xVal <= p1.x) || (xVal >= p1.x && xVal <= p0.x)) {
                    const t = (xVal - p0.x) / (p1.x - p0.x);
                    return p0.y + t * (p1.y - p0.y);
                }
            }
            
            // Return closest point if outside range
            if (xVal < profileData[0].x) return profileData[0].y;
            if (xVal > profileData[profileData.length - 1].x) return profileData[profileData.length - 1].y;
            
            return null;
        }

        function calculateAreaUnderCurve(profileData, startX, endX) {
            if (!profileData || profileData.length < 2) return null;
            
            let area = 0;
            const step = 0.1; // Fine resolution for area calculation
            
            for (let x = startX; x < endX; x += step) {
                const y1 = interpolateYFromProfile(profileData, x);
                const y2 = interpolateYFromProfile(profileData, Math.min(x + step, endX));
                
                if (y1 !== null && y2 !== null) {
                    area += ((y1 + y2) / 2) * step; // Trapezoidal rule
                }
            }
            
            return area;
        }

        function segmentsOverlap(seg1, seg2) {
            const seg1Start = Math.min(seg1.x1Ft, seg1.x2Ft);
            const seg1End = Math.max(seg1.x1Ft, seg1.x2Ft);
            const seg2Start = Math.min(seg2.x1Ft, seg2.x2Ft);
            const seg2End = Math.max(seg2.x1Ft, seg2.x2Ft);
            
            return seg1Start < seg2End && seg2Start < seg1End;
        }

        // ===================== Annotations: helpers and plugin =====================
        let annotationIdCounter = 1;

        function ensureAzAnnotations(az) {
            if (!state.annotationsByAzimuth[az]) {
                state.annotationsByAzimuth[az] = { points: [], segments: [], visible: true };
            }
            return state.annotationsByAzimuth[az];
        }

        function getPointStyle(type) {
            switch (type) {
                case 'crest-main': return { color: '#f59e0b', radius: 5 };
                case 'crest-local': return { color: '#fb923c', radius: 4 };
                case 'base-main': return { color: '#3b82f6', radius: 5 };
                case 'base-local': return { color: '#60a5fa', radius: 4 };
                case 'structure': return { color: '#64748b', radius: 4 };
                default: return { color: '#0ea5e9', radius: 4 };
            }
        }

        function getSegmentStyle(segClass) {
            switch (segClass) {
                case 'non-significant': return { color: 'rgba(100,116,139,0.18)', border: '#64748b' };
                case 'significant': return { color: 'rgba(34,197,94,0.18)', border: '#22c55e' };
                case 'excluded': return { color: 'rgba(239,68,68,0.18)', border: '#ef4444' };
                default: return { color: 'rgba(79,70,229,0.14)', border: '#4f46e5' };
            }
        }

        // Inline SVG icons for annotation types used in the floating editor header
        function getPointTypeIcon(type) {
            // Icons are 14x14, stroke uses currentColor so header background color remains visible
            switch (type) {
                case 'crest-main':
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17l6-10 4 7 2-3 6 6"/><circle cx="4" cy="18" r="1.5"/><circle cx="19" cy="17" r="1.5"/></svg>';
                case 'crest-local':
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 16l5-8 3 5 2-2 6 5"/></svg>';
                case 'base-main':
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 20h18"/><path d="M6 16v4"/><path d="M10 14v6"/><path d="M14 12v8"/><path d="M18 15v5"/></svg>';
                case 'base-local':
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 20h18"/><path d="M8 16v4"/><path d="M12 13v7"/><path d="M16 15v5"/></svg>';
                case 'structure':
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="6" width="14" height="12" rx="2"/><path d="M9 10h6M9 14h6"/></svg>';
                default:
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="4"/></svg>';
            }
        }

        function getSegmentTypeIcon(segClass) {
            switch (segClass) {
                case 'significant':
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h16"/><path d="M8 8l8 8"/></svg>';
                case 'excluded':
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h16"/><path d="M6 6l12 12"/></svg>';
                case 'non-significant':
                default:
                    return '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h16"/></svg>';
            }
        }

        function unitXToFt(xVal) { return xVal * FT_PER_UNIT[state.units.profileDistance]; }
        function unitYToFt(yVal) { return yVal * FT_PER_UNIT[state.units.profileElevation]; }
        function ftToUnitX(xFt) { return convertFromFt(xFt, state.units.profileDistance); }
        function ftToUnitY(yFt) { return convertFromFt(yFt, state.units.profileElevation); }

        function interpolateY(chart, xVal) {
            const datasets = chart.data.datasets || [];
            let best = null;
            for (const ds of datasets) {
                const arr = ds.data || [];
                for (let i = 1; i < arr.length; i++) {
                    const p0 = arr[i - 1], p1 = arr[i];
                    if ((xVal >= p0.x && xVal <= p1.x) || (xVal >= p1.x && xVal <= p0.x)) {
                        const t = (xVal - p0.x) / (p1.x - p0.x);
                        return p0.y + t * (p1.y - p0.y);
                    }
                }
                const xMin = arr[0]?.x, xMax = arr[arr.length - 1]?.x;
                if (xMin != null && xMax != null) {
                    const clamped = Math.max(Math.min(xVal, xMax), xMin);
                    const dy = Math.abs(clamped - xVal);
                    if (!best || dy < best.dy) best = { dy, y: clamped === xMin ? arr[0].y : arr[arr.length - 1].y };
                }
            }
            return best ? best.y : null;
        }

        const kztAnnotationsPlugin = {
            id: 'kztAnnotations',
            beforeDatasetsDraw(chart) {
                const az = chart.$azimuth;
                if (az == null) return;
                const anno = state.annotationsByAzimuth[az];
                if (!anno || !anno.visible) return;
                const { ctx, chartArea, scales } = chart;
                const xScale = scales.x, yScale = scales.y;
                if (!chartArea || !xScale || !yScale) return;

                if (anno.segments?.length) {
                    for (const seg of anno.segments) {
                        const style = getSegmentStyle(seg.class || 'non-significant');
                        const x1 = xScale.getPixelForValue(ftToUnitX(Math.min(seg.x1Ft, seg.x2Ft)));
                        const x2 = xScale.getPixelForValue(ftToUnitX(Math.max(seg.x1Ft, seg.x2Ft)));
                        const left = Math.max(chartArea.left, Math.min(x1, x2));
                        const right = Math.min(chartArea.right, Math.max(x1, x2));
                        if (right <= left) continue;
                        ctx.save();
                        ctx.fillStyle = style.color;
                        ctx.fillRect(left, chartArea.top, right - left, chartArea.bottom - chartArea.top);
                        ctx.strokeStyle = style.border;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(left, chartArea.top, right - left, chartArea.bottom - chartArea.top);
                        if (seg.label) {
                            ctx.fillStyle = '#1f2937';
                            ctx.font = 'bold 11px Inter, Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'top';
                            ctx.fillText(seg.label, (left + right) / 2, chartArea.top + 2);
                        }
                        ctx.restore();
                    }
                }

                if (anno.points?.length) {
                    for (const pt of anno.points) {
                        const style = getPointStyle(pt.type);
                        const x = xScale.getPixelForValue(ftToUnitX(pt.xFt));
                        const y = yScale.getPixelForValue(ftToUnitY(pt.yFt));
                        if (x < chartArea.left || x > chartArea.right || y < chartArea.top || y > chartArea.bottom) continue;
                        ctx.save();
                        ctx.fillStyle = style.color;
                        ctx.beginPath();
                        ctx.arc(x, y, style.radius, 0, Math.PI * 2);
                        ctx.fill();
                        if (pt.label) {
                            ctx.font = 'bold 11px Inter, Arial';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'bottom';
                            ctx.fillStyle = '#111827';
                            ctx.fillText(pt.label, x + style.radius + 3, y - style.radius - 2);
                        }
                        ctx.restore();
                    }
                }
            }
        };

        let pluginRegistered = false;

        // =================================================================================
        // FLOATING ANNOTATION EDITOR - Core Functions
        // =================================================================================

        // Initialize floating annotation editor
        function initializeFloatingAnnotationEditor() {
            console.log('Initializing floating annotation editor...');
            const editor = document.getElementById('floating-annotation-editor');
            if (!editor) {
                console.error('Floating annotation editor element not found during initialization!');
                return;
            }

            console.log('Floating annotation editor found, setting up...');
            // Setup event listeners
            setupAnnotationEditorEventListeners();
            setupAnnotationEditorDragging();
            setupAnnotationSectionToggling();
            console.log('Floating annotation editor initialized successfully');
        }

        // Show floating annotation editor with annotation data
        function showFloatingAnnotationEditor(annotation, azimuth, type) {
            console.log('showFloatingAnnotationEditor called:', { annotation, azimuth, type });
            
            const editor = document.getElementById('floating-annotation-editor');
            if (!editor) {
                console.error('Floating annotation editor element not found!');
                return;
            }

            floatingAnnotationEditor.currentAnnotation = annotation;
            floatingAnnotationEditor.currentAzimuth = azimuth;
            floatingAnnotationEditor.isVisible = true;

            // Update header
            updateAnnotationEditorHeader(annotation, type);

            // Populate edit form
            populateAnnotationEditForm(annotation, type);

            // Calculate and display properties
            const calculations = calculateAnnotationProperties(annotation, azimuth, type);
            console.log('Calculated properties:', calculations);
            populateAnnotationCalculations(calculations, type);

            // Show/hide sections based on type
            updateSectionVisibility(type);

            // Show editor with animation
            editor.classList.add('visible');
            console.log('Floating annotation editor should now be visible');
        }

        // Hide floating annotation editor
        function hideFloatingAnnotationEditor() {
            const editor = document.getElementById('floating-annotation-editor');
            if (!editor) return;

            editor.classList.remove('visible');
            floatingAnnotationEditor.isVisible = false;
            floatingAnnotationEditor.currentAnnotation = null;
            floatingAnnotationEditor.currentAzimuth = null;
        }

        // Update annotation editor header
        function updateAnnotationEditorHeader(annotation, type) {
            const icon = document.getElementById('annotation-type-icon');
            const title = document.getElementById('annotation-title');
            
            if (type === 'point') {
                const style = getPointStyle(annotation.type);
                icon.style.background = style.color;
                icon.innerHTML = getPointTypeIcon(annotation.type);
                title.textContent = `Point: ${annotation.label}`;
            } else if (type === 'segment') {
                const style = getSegmentStyle(annotation.class);
                icon.style.background = style.border;
                icon.innerHTML = getSegmentTypeIcon(annotation.class);
                title.textContent = `Segment: ${annotation.label}`;
            }
        }

        // Populate edit form based on annotation type
        function populateAnnotationEditForm(annotation, type) {
            const form = document.getElementById('annotation-edit-form');
            if (!form) return;

            const distUnit = state.units.profileDistance;
            const elevUnit = state.units.profileElevation;

            if (type === 'point') {
                form.innerHTML = `
                    <div class="form-group">
                        <label class="form-label">Label</label>
                        <input type="text" class="form-input" id="edit-label" value="${annotation.label}" placeholder="Point label">
                    </div>
                    <div class="form-group-inline">
                        <div class="form-group">
                            <label class="form-label">X Coordinate (${distUnit})</label>
                            <input type="number" class="form-input" id="edit-x" value="${ftToUnitX(annotation.xFt).toFixed(1)}" step="0.1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Y Coordinate (${elevUnit})</label>
                            <input type="number" class="form-input" id="edit-y" value="${ftToUnitY(annotation.yFt).toFixed(1)}" step="0.1">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Point Type</label>
                        <select class="form-select" id="edit-type">
                            <option value="crest-main" ${annotation.type === 'crest-main' ? 'selected' : ''}>Crest Main</option>
                            <option value="crest-local" ${annotation.type === 'crest-local' ? 'selected' : ''}>Crest Local</option>
                            <option value="base-main" ${annotation.type === 'base-main' ? 'selected' : ''}>Base Main</option>
                            <option value="base-local" ${annotation.type === 'base-local' ? 'selected' : ''}>Base Local</option>
                            <option value="structure" ${annotation.type === 'structure' ? 'selected' : ''}>Structure</option>
                        </select>
                    </div>
                    <div class="form-actions">
                        <button class="form-btn form-btn-primary" onclick="saveAnnotationChanges()">Save Changes</button>
                        <button class="form-btn form-btn-secondary" onclick="hideFloatingAnnotationEditor()">Cancel</button>
                        <button class="form-btn form-btn-danger" onclick="deleteCurrentAnnotation()">Delete</button>
                    </div>
                `;
            } else if (type === 'segment') {
                form.innerHTML = `
                    <div class="form-group">
                        <label class="form-label">Label</label>
                        <input type="text" class="form-input" id="edit-label" value="${annotation.label}" placeholder="Segment label">
                    </div>
                    <div class="form-group-inline">
                        <div class="form-group">
                            <label class="form-label">Start X (${distUnit})</label>
                            <input type="number" class="form-input" id="edit-x1" value="${ftToUnitX(annotation.x1Ft).toFixed(1)}" step="0.1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">End X (${distUnit})</label>
                            <input type="number" class="form-input" id="edit-x2" value="${ftToUnitX(annotation.x2Ft).toFixed(1)}" step="0.1">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Segment Class</label>
                        <select class="form-select" id="edit-class">
                            <option value="non-significant" ${annotation.class === 'non-significant' ? 'selected' : ''}>Non-Significant</option>
                            <option value="significant" ${annotation.class === 'significant' ? 'selected' : ''}>Significant</option>
                            <option value="excluded" ${annotation.class === 'excluded' ? 'selected' : ''}>Excluded</option>
                        </select>
                    </div>
                    <div class="form-actions">
                        <button class="form-btn form-btn-primary" onclick="saveAnnotationChanges()">Save Changes</button>
                        <button class="form-btn form-btn-secondary" onclick="hideFloatingAnnotationEditor()">Cancel</button>
                        <button class="form-btn form-btn-danger" onclick="deleteCurrentAnnotation()">Delete</button>
                    </div>
                `;
            }
        }

        // Populate calculation sections
        function populateAnnotationCalculations(calculations, type) {
            populateBasicCalculations(calculations.basic || {}, type);
            populateAdvancedCalculations(calculations.advanced || {}, type);
            
            if (type === 'segment' && calculations.points) {
                populatePointAnalysis(calculations.points);
            }
        }

        function populateBasicCalculations(basic, type) {
            const container = document.getElementById('basic-calculations-grid');
            if (!container) return;

            const className = type === 'point' ? 'point-calculations' : 'segment-calculations';
            container.className = `calculation-grid ${className}`;

            container.innerHTML = Object.entries(basic).map(([key, calc]) => `
                <div class="calculation-item">
                    <div class="calculation-label">${calc.label}</div>
                    <div class="calculation-value">
                        ${calc.value}
                        ${calc.unit ? `<span class="calculation-unit">${calc.unit}</span>` : ''}
                        ${calc.status ? `<span class="calculation-status ${calc.status}">${calc.status}</span>` : ''}
                    </div>
                </div>
            `).join('');
        }

        function populateAdvancedCalculations(advanced, type) {
            const container = document.getElementById('advanced-analysis-grid');
            if (!container) return;

            const className = type === 'point' ? 'point-calculations' : 'segment-calculations';
            container.className = `calculation-grid ${className}`;

            if (Object.keys(advanced).length === 0) {
                container.innerHTML = '<div class="calculation-item"><div class="calculation-label">No advanced analysis available</div></div>';
                return;
            }

            container.innerHTML = Object.entries(advanced).map(([key, calc]) => `
                <div class="calculation-item">
                    <div class="calculation-label">${calc.label}</div>
                    <div class="calculation-value">
                        ${calc.value}
                        ${calc.unit ? `<span class="calculation-unit">${calc.unit}</span>` : ''}
                        ${calc.status ? `<span class="calculation-status ${calc.status}">${calc.status}</span>` : ''}
                    </div>
                </div>
            `).join('');
        }

        function populatePointAnalysis(pointAnalysis) {
            const container = document.getElementById('point-details-grid');
            if (!container) return;

            container.innerHTML = `
                <div class="calculation-subsection">
                    <div class="subsection-title">Segment Point Analysis</div>
                    <div class="calculation-grid">
                        <div class="calculation-item">
                            <div class="calculation-label">${pointAnalysis.start.label}</div>
                            <div class="calculation-value">
                                ${pointAnalysis.start.coordinates}
                                <span class="calculation-unit">${pointAnalysis.start.unit}</span>
                            </div>
                        </div>
                        <div class="calculation-item">
                            <div class="calculation-label">${pointAnalysis.middle.label}</div>
                            <div class="calculation-value">
                                ${pointAnalysis.middle.coordinates}
                                <span class="calculation-unit">${pointAnalysis.middle.unit}</span>
                            </div>
                        </div>
                        <div class="calculation-item">
                            <div class="calculation-label">${pointAnalysis.end.label}</div>
                            <div class="calculation-value">
                                ${pointAnalysis.end.coordinates}
                                <span class="calculation-unit">${pointAnalysis.end.unit}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Update section visibility based on annotation type
        function updateSectionVisibility(type) {
            const pointDetailsSection = document.getElementById('point-details-section');
            if (pointDetailsSection) {
                pointDetailsSection.style.display = type === 'segment' ? 'block' : 'none';
            }
        }

        // Save annotation changes
        function saveAnnotationChanges() {
            if (!floatingAnnotationEditor.currentAnnotation || !floatingAnnotationEditor.currentAzimuth) return;

            const azimuth = floatingAnnotationEditor.currentAzimuth;
            const annotation = floatingAnnotationEditor.currentAnnotation;
            const anno = ensureAzAnnotations(azimuth);

            // Determine annotation type
            const isPoint = annotation.hasOwnProperty('xFt') && annotation.hasOwnProperty('yFt');
            const isSegment = annotation.hasOwnProperty('x1Ft') && annotation.hasOwnProperty('x2Ft');

            try {
                if (isPoint) {
                    // Update point annotation
                    const newLabel = document.getElementById('edit-label').value.trim();
                    const newX = parseFloat(document.getElementById('edit-x').value);
                    const newY = parseFloat(document.getElementById('edit-y').value);
                    const newType = document.getElementById('edit-type').value;

                    if (!newLabel || isNaN(newX) || isNaN(newY)) {
                        alert('Please provide valid label and coordinates.');
                        return;
                    }

                    annotation.label = newLabel;
                    annotation.xFt = unitXToFt(newX);
                    annotation.yFt = unitYToFt(newY);
                    annotation.type = newType;

                } else if (isSegment) {
                    // Update segment annotation
                    const newLabel = document.getElementById('edit-label').value.trim();
                    const newX1 = parseFloat(document.getElementById('edit-x1').value);
                    const newX2 = parseFloat(document.getElementById('edit-x2').value);
                    const newClass = document.getElementById('edit-class').value;

                    if (!newLabel || isNaN(newX1) || isNaN(newX2)) {
                        alert('Please provide valid label and coordinates.');
                        return;
                    }

                    annotation.label = newLabel;
                    annotation.x1Ft = unitXToFt(newX1);
                    annotation.x2Ft = unitXToFt(newX2);
                    annotation.class = newClass;
                }

                // Update chart
                chartInstances[azimuth]?.update('none');

                // Refresh calculations
                const type = isPoint ? 'point' : 'segment';
                const calculations = calculateAnnotationProperties(annotation, azimuth, type);
                populateAnnotationCalculations(calculations, type);

                // Update header if needed
                updateAnnotationEditorHeader(annotation, type);

                // Show success feedback
                showSaveSuccessAnimation();

            } catch (error) {
                console.error('Error saving annotation changes:', error);
                alert('Error saving changes. Please try again.');
            }
        }

        // Delete current annotation
        function deleteCurrentAnnotation() {
            if (!floatingAnnotationEditor.currentAnnotation || !floatingAnnotationEditor.currentAzimuth) return;

            if (!confirm('Are you sure you want to delete this annotation?')) return;

            const azimuth = floatingAnnotationEditor.currentAzimuth;
            const annotation = floatingAnnotationEditor.currentAnnotation;
            const anno = ensureAzAnnotations(azimuth);

            // Determine annotation type and remove from appropriate array
            const isPoint = annotation.hasOwnProperty('xFt') && annotation.hasOwnProperty('yFt');
            
            if (isPoint) {
                const index = anno.points.findIndex(p => p.id === annotation.id);
                if (index !== -1) {
                    anno.points.splice(index, 1);
                }
            } else {
                const index = anno.segments.findIndex(s => s.id === annotation.id);
                if (index !== -1) {
                    anno.segments.splice(index, 1);
                }
            }

            // Update chart
            chartInstances[azimuth]?.update('none');

            // Hide editor
            hideFloatingAnnotationEditor();
        }

        // Show save success animation
        function showSaveSuccessAnimation() {
            const saveBtn = document.querySelector('.form-btn-primary');
            if (saveBtn) {
                const originalText = saveBtn.textContent;
                saveBtn.textContent = 'Saved!';
                saveBtn.style.background = '#10b981';
                
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '';
                }, 1500);
            }
        }

        // Setup annotation editor event listeners
        function setupAnnotationEditorEventListeners() {
            // Close button
            const closeBtn = document.getElementById('close-annotation-editor');
            if (closeBtn) {
                closeBtn.addEventListener('click', hideFloatingAnnotationEditor);
            }

            // Minimize button
            const minimizeBtn = document.getElementById('minimize-annotation-editor');
            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', toggleAnnotationEditorMinimize);
            }

            // Escape key to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && floatingAnnotationEditor.isVisible) {
                    hideFloatingAnnotationEditor();
                }
            });
        }

        // Setup dragging functionality for annotation editor
        function setupAnnotationEditorDragging() {
            const header = document.querySelector('.annotation-editor-header');
            const editor = document.getElementById('floating-annotation-editor');
            
            if (!header || !editor) return;

            let isDragging = false;
            let startX, startY, initialX, initialY;

            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = editor.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                
                header.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const newX = initialX + deltaX;
                const newY = initialY + deltaY;
                
                // Constrain to viewport
                const maxX = window.innerWidth - editor.offsetWidth;
                const maxY = window.innerHeight - editor.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(newX, maxX));
                const constrainedY = Math.max(0, Math.min(newY, maxY));
                
                editor.style.left = constrainedX + 'px';
                editor.style.top = constrainedY + 'px';
                editor.style.right = 'auto';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    header.style.cursor = 'move';
                }
            });
        }

        // Setup section toggling functionality
        function setupAnnotationSectionToggling() {
            document.addEventListener('click', (e) => {
                const sectionHeader = e.target.closest('.annotation-section-header');
                if (!sectionHeader) return;

                const section = sectionHeader.parentElement;
                const content = section.querySelector('.annotation-section-content');
                const toggle = sectionHeader.querySelector('.annotation-section-toggle');

                if (!content || !toggle) return;

                const isCollapsed = content.classList.contains('collapsed');
                
                if (isCollapsed) {
                    // Expand
                    content.classList.remove('collapsed');
                    toggle.classList.remove('collapsed');
                } else {
                    // Collapse
                    content.classList.add('collapsed');
                    toggle.classList.add('collapsed');
                }
            });
        }

        // Toggle minimize state
        function toggleAnnotationEditorMinimize() {
            const editor = document.getElementById('floating-annotation-editor');
            if (!editor) return;

            floatingAnnotationEditor.isMinimized = !floatingAnnotationEditor.isMinimized;
            
            if (floatingAnnotationEditor.isMinimized) {
                editor.classList.add('minimized');
            } else {
                editor.classList.remove('minimized');
            }
        }

        // Enhanced Chart.js plugin with right-click detection
        const enhancedKztAnnotationsPlugin = {
            id: 'enhancedKztAnnotations',
            beforeDatasetsDraw(chart) {
                // Call original drawing function
                kztAnnotationsPlugin.beforeDatasetsDraw.call(this, chart);
            },
            afterEvent(chart, args) {
                const { event } = args;
                const az = chart.$azimuth;
                
                console.log('Enhanced plugin afterEvent:', { eventType: event.type, azimuth: az, hasAzimuth: !!az });
                
                if (!az || event.type !== 'contextmenu') return;
                
                // Prevent default context menu
                event.native.preventDefault();
                
                const anno = state.annotationsByAzimuth[az];
                console.log('Annotations for azimuth:', { azimuth: az, annotations: anno });
                
                if (!anno || !anno.visible) return;
                
                const { chartArea, scales } = chart;
                const xScale = scales.x;
                const yScale = scales.y;
                
                if (!chartArea || !xScale || !yScale) return;
                
                const canvasX = event.x;
                const canvasY = event.y;
                
                console.log('Right-click detected at:', { x: canvasX, y: canvasY });
                
                // Check if right-click hit any annotation
                const clickedAnnotation = findAnnotationAtPosition(anno, canvasX, canvasY, chartArea, xScale, yScale);
                console.log('Found annotation:', clickedAnnotation);
                
                if (clickedAnnotation) {
                    console.log('Showing floating annotation editor');
                    showFloatingAnnotationEditor(clickedAnnotation.annotation, az, clickedAnnotation.type);
                } else {
                    console.log('No annotation found at click position');
                }
            }
        };

        // Find annotation at mouse position
        function findAnnotationAtPosition(annotations, x, y, chartArea, xScale, yScale) {
            // Check points first (smaller targets, higher priority)
            if (annotations.points) {
                for (const point of annotations.points) {
                    const style = getPointStyle(point.type);
                    const pointX = xScale.getPixelForValue(ftToUnitX(point.xFt));
                    const pointY = yScale.getPixelForValue(ftToUnitY(point.yFt));
                    
                    const distance = Math.sqrt(Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2));
                    
                    if (distance <= style.radius + 5) { // 5px tolerance
                        return { annotation: point, type: 'point' };
                    }
                }
            }
            
            // Check segments
            if (annotations.segments) {
                for (const segment of annotations.segments) {
                    const x1 = xScale.getPixelForValue(ftToUnitX(Math.min(segment.x1Ft, segment.x2Ft)));
                    const x2 = xScale.getPixelForValue(ftToUnitX(Math.max(segment.x1Ft, segment.x2Ft)));
                    
                    const left = Math.max(chartArea.left, Math.min(x1, x2));
                    const right = Math.min(chartArea.right, Math.max(x1, x2));
                    
                    if (x >= left && x <= right && y >= chartArea.top && y <= chartArea.bottom) {
                        return { annotation: segment, type: 'segment' };
                    }
                }
            }
            
            return null;
        }

        // --- DEMO DATA GENERATOR ---
        function generateRealisticProfileData(azimuth, baseElevation) {
            const points = [];
            const numPoints = 15 + Math.floor(Math.random() * 10); // 15-25 points
            const totalDistance = 8000 + Math.random() * 4000; // 8-12km total
            
            // Create varying terrain based on azimuth
            const terrainVariation = Math.sin((azimuth * Math.PI) / 180) * 200 + Math.cos((azimuth * Math.PI) / 90) * 150;
            
            for (let i = 0; i < numPoints; i++) {
                const progress = (i / (numPoints - 1)) - 0.5; // -0.5 to 0.5
                const distance = progress * totalDistance;
                
                // Generate realistic elevation profile
                let elevation = baseElevation;
                
                if (distance < 0) {
                    // Upwind side - gradual rise to crest
                    const upwindFactor = Math.abs(distance) / (totalDistance / 2);
                    elevation += terrainVariation * (1 - upwindFactor * upwindFactor) + Math.random() * 100 - 50;
                } else {
                    // Downwind side - steeper drop from crest
                    const downwindFactor = distance / (totalDistance / 2);
                    elevation += terrainVariation * (1 - downwindFactor * 1.5) + Math.random() * 80 - 40;
                }
                
                // Ensure minimum elevation
                elevation = Math.max(elevation, baseElevation * 0.1);
                
                points.push({ 
                    distance: Math.round(distance), 
                    elevation: Math.round(elevation * 10) / 10 
                });
            }
            
            // Sort by distance and ensure crest point exists
            points.sort((a, b) => a.distance - b.distance);
            
            // Find closest point to distance 0 and adjust to be the crest
            let crestIndex = 0;
            let minDist = Math.abs(points[0].distance);
            for (let i = 1; i < points.length; i++) {
                if (Math.abs(points[i].distance) < minDist) {
                    minDist = Math.abs(points[i].distance);
                    crestIndex = i;
                }
            }
            points[crestIndex] = { distance: 0, elevation: baseElevation };
            
            return points;
        }

        function generateDiametralProfileData(azimuth, baseElevation) {
            // Generate profile for current azimuth (positive side)
            const currentProfile = generateRealisticProfileData(azimuth, baseElevation);
            
            // Generate profile for opposite azimuth (negative side)
            const oppositeAzimuth = (azimuth + 180) % 360;
            const oppositeProfile = generateRealisticProfileData(oppositeAzimuth, baseElevation);
            
            // Combine profiles: opposite on left (negative distances), current on right (positive distances)
            const combinedPoints = [];
            
            // Add opposite azimuth points (mirrored to negative distances)
            oppositeProfile.forEach(point => {
                if (point.distance > 0) { // Only take positive distances from opposite profile
                    combinedPoints.push({
                        distance: -point.distance, // Mirror to negative
                        elevation: point.elevation
                    });
                }
            });
            
            // Add current azimuth points (positive distances)
            currentProfile.forEach(point => {
                combinedPoints.push({
                    distance: point.distance,
                    elevation: point.elevation
                });
            });
            
            // Sort by distance and ensure crest point exists at 0
            combinedPoints.sort((a, b) => a.distance - b.distance);
            
            // Ensure crest point at distance 0
            const crestIndex = combinedPoints.findIndex(p => p.distance === 0);
            if (crestIndex === -1) {
                combinedPoints.push({ distance: 0, elevation: baseElevation });
                combinedPoints.sort((a, b) => a.distance - b.distance);
            }
            
            return combinedPoints;
        }

        function generateAzimuthData(azimuth) {
            // Base coordinates vary by region
            const baseCoords = [
                { lat: 40.71, lon: -74.01, elev: 731.2 }, // NYC area
                { lat: 41.88, lon: -87.63, elev: 850.6 }, // Chicago area  
                { lat: 34.05, lon: -118.24, elev: 650.3 }, // LA area
                { lat: 39.95, lon: -75.17, elev: 420.8 }, // Philadelphia area
                { lat: 42.36, lon: -71.06, elev: 580.2 }  // Boston area
            ];
            const coord = baseCoords[azimuth % baseCoords.length];
            
            // Vary coordinates slightly for each azimuth
            const latOffset = (Math.sin(azimuth * Math.PI / 180) * 0.02);
            const lonOffset = (Math.cos(azimuth * Math.PI / 180) * 0.03);
            const elevOffset = (Math.sin(azimuth * Math.PI / 90) * 100);
            
            const crestElev = coord.elev + elevOffset;
            const structElev = crestElev * (0.15 + Math.random() * 0.25); // 15-40% of crest height
            
            // Generate realistic parameters based on azimuth
            const H = Math.round((crestElev - structElev) * 10) / 10;
            const Lh = Math.round((H * (1.5 + Math.random() * 2)) * 10) / 10; // 1.5-3.5 times H
            const x = Math.round(((Math.random() - 0.5) * H * 1.2) * 10) / 10; // Within reasonable range
            
            // Calculate realistic selection summary
            const L = Math.round((Lh * (8 + Math.random() * 4)) * 10) / 10; // 8-12 times Lh
            const Mid = crestElev * (0.4 + Math.random() * 0.3); // 40-70% of crest
            const distToMid = Math.round((Lh * (0.8 + Math.random() * 0.4)) * 10) / 10;
            
            // Kzt matrix with realistic variations
            const baseKzt = 1.1 + Math.random() * 0.3; // 1.1 to 1.4 base
            const kztMatrix = {
                none: { B: 1.000, C: 1.000, D: 1.000 },
                ridge2D: { 
                    B: Math.round((baseKzt * 0.9) * 1000) / 1000,
                    C: Math.round(baseKzt * 1000) / 1000,
                    D: Math.round((baseKzt * 1.1) * 1000) / 1000
                },
                escarp: { 
                    B: Math.round((baseKzt * 0.75) * 1000) / 1000,
                    C: Math.round((baseKzt * 0.8) * 1000) / 1000,
                    D: Math.round((baseKzt * 0.85) * 1000) / 1000
                },
                hill3D: { 
                    B: Math.round((baseKzt * 0.85) * 1000) / 1000,
                    C: Math.round((baseKzt * 0.9) * 1000) / 1000,
                    D: Math.round((baseKzt * 0.95) * 1000) / 1000
                }
            };
            
            // Choose default shape and exposure
            const shapes = ['ridge2D', 'escarp', 'hill3D'];
            const exposures = ['B', 'C', 'D'];
            const defaultShape = shapes[azimuth % shapes.length];
            const defaultExposure = exposures[Math.floor(azimuth / 8) % exposures.length];
            
            return {
                status: 'success',
                windDirection: azimuth,
                isCollapsed: true,
                isIncluded: true, // All cards included by default
                H: H,
                Lh: Lh,
                x: x,
                z: 0.0,
                location: x >= 0 ? 'Downwind' : 'Upwind',
                defaultShape: defaultShape,
                defaultExposure: defaultExposure,
                defaultKzt: kztMatrix[defaultShape][defaultExposure],
                selectionSummary: {
                    L: L,
                    Top: Math.round(crestElev * 10) / 10,
                    Mid: Math.round(Mid * 10) / 10,
                    Bottom: Math.round(structElev * 10) / 10,
                    distToMid: distToMid,
                    slopePct: Math.round(((crestElev - structElev) / distToMid * 100) * 100) / 100
                },
                kztParams: {
                    H: H,
                    Lh: Lh,
                    x: x,
                    z: 0.0,
                    K1: Math.round((0.3 + Math.random() * 0.4) * 1000) / 1000,
                    K2: Math.round((0.8 + Math.random() * 0.2) * 1000) / 1000,
                    K3: 1.000,
                    mu: Math.round((0.7 + Math.random() * 0.2) * 1000) / 1000,
                    gamma: Math.round((0.85 + Math.random() * 0.15) * 1000) / 1000,
                    kzt: kztMatrix[defaultShape][defaultExposure]
                },
                siteInfo: {
                    crestCoords: { 
                        lat: Math.round((coord.lat + latOffset) * 100000) / 100000,
                        lon: Math.round((coord.lon + lonOffset) * 100000) / 100000
                    },
                    crestElev: Math.round(crestElev * 10) / 10,
                    structCoords: { 
                        lat: Math.round((coord.lat + latOffset + 0.01) * 100000) / 100000,
                        lon: Math.round((coord.lon + lonOffset + 0.01) * 100000) / 100000
                    },
                    structElev: Math.round(structElev * 10) / 10,
                    exposure: defaultExposure,
                    topoFeature: defaultShape.replace('ridge2D', '2D Ridge').replace('escarp', '2D Escarpment').replace('hill3D', '3D Hill')
                },
                profileData: generateRealisticProfileData(azimuth, crestElev),
                kztMatrix: kztMatrix
            };
        }

        // --- DEMO DATA --- In a real application, this data would be passed into the `initializeApp` function.
        // Generate complete 24-azimuth dataset
        const sampleResults = [];
        for (let azimuth = 0; azimuth < 360; azimuth += 15) {
            sampleResults.push(generateAzimuthData(azimuth));
        }
        
        // --- Centralized Color Palette ---
        const AZIMUTH_COLORS = [
            { line: '#0ea5e9', bg: 'bg-sky-200', text: 'text-sky-800' },       // Sky
            { line: '#f59e0b', bg: 'bg-amber-200', text: 'text-amber-800' },    // Amber
            { line: '#10b981', bg: 'bg-emerald-200', text: 'text-emerald-800' }, // Emerald
            { line: '#ef4444', bg: 'bg-red-200', text: 'text-red-800' },         // Red
            { line: '#a855f7', bg: 'bg-purple-200', text: 'text-purple-800' },   // Purple
            { line: '#6366f1', bg: 'bg-indigo-200', text: 'text-indigo-800' },   // Indigo
            { line: '#ec4899', bg: 'bg-pink-200', text: 'text-pink-800' },       // Pink
            { line: '#84cc16', bg: 'bg-lime-200', text: 'text-lime-800' },       // Lime
        ];

        function getAzimuthColor(azimuth) {
            const index = (Math.round(azimuth / 15)) % AZIMUTH_COLORS.length;
            return AZIMUTH_COLORS[index];
        }

        // --- Color utilities to ensure proper alpha backgrounds regardless of input format ---
        function hexToRgba(hex, alpha = 1) {
            if (!hex) return `rgba(0,0,0,${alpha})`;
            const normalized = hex.replace('#', '');
            const bigint = parseInt(normalized.length === 3
                ? normalized.split('').map(c => c + c).join('')
                : normalized, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        function colorWithAlpha(color, alpha) {
            if (!color) return hexToRgba('#000000', alpha);
            // If already rgba(a), just replace alpha
            if (color.startsWith('rgba(')) {
                const parts = color
                    .replace('rgba(', '')
                    .replace(')', '')
                    .split(',')
                    .map(s => s.trim());
                return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
            }
            // If rgb(), convert to rgba
            if (color.startsWith('rgb(')) {
                return color.replace('rgb(', 'rgba(').replace(')', `, ${alpha})`);
            }
            // Assume hex otherwise
            return hexToRgba(color, alpha);
        }

        // =================================================================================
        // SECTION MIRRORING HELPERS
        // =================================================================================

        function shouldMirrorSections() {
            return state.mirrorSectionsLg && window.innerWidth >= 1024; // lg breakpoint
        }

        function findMirrorCard(currentCard) {
            if (!shouldMirrorSections()) return null;
            
            const container = document.getElementById('card-container');
            const cards = Array.from(container.querySelectorAll('.kzt-card:not(.lg\\:col-span-2)'));
            const currentIndex = cards.indexOf(currentCard);
            
            if (currentIndex === -1) return null;
            
            // Check if cards are in same row (even/odd pairs on lg grid)
            const isEvenRow = Math.floor(currentIndex / 2) * 2;
            const expectedPairIndex = currentIndex % 2 === 0 ? currentIndex + 1 : currentIndex - 1;
            
            // Ensure the pair card exists and is in the same row
            if (expectedPairIndex >= 0 && expectedPairIndex < cards.length) {
                const pairCard = cards[expectedPairIndex];
                const pairRowStart = Math.floor(expectedPairIndex / 2) * 2;
                if (isEvenRow === pairRowStart) {
                    return pairCard;
                }
            }
            
            return null;
        }

        function getSectionKey(sectionHeader) {
            return sectionHeader.dataset.sectionKey || 
                   sectionHeader.querySelector('.card-section-title')?.textContent?.toLowerCase().replace(/\s+/g, '-');
        }

        function mirrorSectionState(currentCard, sectionKey, isExpanded) {
            const mirrorCard = findMirrorCard(currentCard);
            if (!mirrorCard) return;
            
            const mirrorSection = mirrorCard.querySelector(`[data-section-key="${sectionKey}"]`);
            if (!mirrorSection) return;
            
            const mirrorContent = mirrorSection.nextElementSibling;
            const mirrorIcon = mirrorSection.querySelector('.card-section-toggle');
            
            if (!mirrorContent || !mirrorIcon) return;
            
            const isMirrorExpanded = !mirrorContent.classList.contains('is-collapsed');
            
            // Only mirror if states are different
            if (isExpanded !== isMirrorExpanded) {
                if (isExpanded) {
                    expandSection(mirrorContent, mirrorIcon);
                    
                    // If this is a graph section, render the chart for the mirror card too
                    if (sectionKey === 'graph') {
                        const mirrorAzimuth = mirrorCard.dataset.azimuth;
                        if (mirrorAzimuth) {
                            setTimeout(() => renderSingleChart(parseInt(mirrorAzimuth)), 150);
                        }
                    }
                } else {
                    collapseSection(mirrorContent, mirrorIcon);
                }
            }
        }

        // =================================================================================
        // COLLAPSIBLE SECTION HELPERS
        // =================================================================================

        const roMap = new WeakMap();
        
        function expandSection(content, icon) {
            if (!content || !icon) return;
            
            icon.classList.remove('is-collapsed');
            content.classList.remove('is-collapsed');
            
            // Get the natural height by temporarily removing max-height
            content.style.maxHeight = 'none';
            const target = content.scrollHeight;
            content.style.maxHeight = '0px';
            
            // Force reflow and then animate to target height
            requestAnimationFrame(() => {
                content.style.maxHeight = target + 'px';
            });
            
            // Set up ResizeObserver for dynamic content
            const ro = roMap.get(content);
            if (ro) ro.disconnect();
            
            const newRo = new ResizeObserver(() => {
                if (!content.classList.contains('is-collapsed')) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            });
            newRo.observe(content);
            roMap.set(content, newRo);
        }
        
        function collapseSection(content, icon) {
            if (!content || !icon) return;
            
            icon.classList.add('is-collapsed');
            content.classList.add('is-collapsed');
            
            // Disconnect ResizeObserver
            const ro = roMap.get(content);
            if (ro) { 
                ro.disconnect(); 
                roMap.delete(content); 
            }
            
            // Set current height and then animate to 0
            content.style.maxHeight = content.scrollHeight + 'px';
            requestAnimationFrame(() => { 
                content.style.maxHeight = '0px'; 
            });
        }

        // =================================================================================
        // UNIT & COORDINATE UTILITIES
        // =================================================================================
        const ALL_UNIT_KEYS = ['ft', 'm', 'yd', 'in', 'km', 'mi'];
        const FT_PER_UNIT = { 'mi': 5280, 'km': 3280.84, 'm': 3.28084, 'ft': 1, 'yd': 3, 'in': 1 / 12 };
        function convertFromFt(valueInFt, toUnit) {
            if (valueInFt === undefined || valueInFt === null) return 'N/A';
            return valueInFt / FT_PER_UNIT[toUnit];
        }
        function getNextUnit(currentUnit) {
            const currentIndex = ALL_UNIT_KEYS.indexOf(currentUnit);
            return ALL_UNIT_KEYS[(currentIndex + 1) % ALL_UNIT_KEYS.length];
        }
        
        // Update unit displays without re-rendering entire cards
        function updateUnitDisplays() {
            // Update all unit-toggle elements
            document.querySelectorAll('.unit-toggle').forEach(element => {
                const paramKey = element.dataset.paramKey;
                if (paramKey && state.units[paramKey]) {
                    const currentUnit = state.units[paramKey];
                    const valueText = element.textContent.trim();
                    const parts = valueText.split(' ');
                    if (parts.length >= 2) {
                        const numericValue = parseFloat(parts[0]);
                        if (!isNaN(numericValue)) {
                            // Find the source data to get original ft value
                            const cards = document.querySelectorAll('.kzt-card, .controlling-case-card');
                            for (const card of cards) {
                                if (card.contains(element)) {
                                    const azimuth = card.dataset.azimuth;
                                    let sourceData = null;
                                    
                                    if (card.classList.contains('controlling-case-card')) {
                                        const includedResults = sampleResults.filter(r => r.status === 'success' && r.isIncluded);
                                        if (includedResults.length > 0) {
                                            sourceData = includedResults.reduce((max, current) => 
                                                current.defaultKzt > max.defaultKzt ? current : max);
                                        }
                                    } else {
                                        sourceData = sampleResults.find(r => r.windDirection == azimuth);
                                    }
                                    
                                    if (sourceData) {
                                        let originalValue = null;
                                        // Get original value in feet from source data
                                        if (sourceData.siteInfo && sourceData.siteInfo[paramKey] !== undefined) {
                                            originalValue = sourceData.siteInfo[paramKey];
                                        } else if (sourceData.selectionSummary && sourceData.selectionSummary[paramKey] !== undefined) {
                                            originalValue = sourceData.selectionSummary[paramKey];
                                        } else if (sourceData.kztParams && sourceData.kztParams[paramKey] !== undefined) {
                                            originalValue = sourceData.kztParams[paramKey];
                                        }
                                        
                                        if (originalValue !== null) {
                                            const newValue = convertFromFt(originalValue, currentUnit);
                                            const precision = ['H', 'Lh', 'x', 'z'].includes(paramKey) ? 1 : 2;
                                            element.textContent = `${newValue.toFixed(precision)} ${currentUnit}`;
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update coordinate displays without re-rendering entire cards
        function updateCoordinateDisplays() {
            document.querySelectorAll('.coord-toggle').forEach(element => {
                // Find which card this element belongs to
                const cards = document.querySelectorAll('.kzt-card, .controlling-case-card');
                for (const card of cards) {
                    if (!card.contains(element)) continue;
                    const azimuth = card.dataset.azimuth;
                    let sourceData = null;

                    if (card.classList.contains('controlling-case-card')) {
                        const includedResults = sampleResults.filter(r => r.status === 'success' && r.isIncluded);
                        if (includedResults.length > 0) {
                            sourceData = includedResults.reduce((max, current) =>
                                current.defaultKzt > max.defaultKzt ? current : max);
                        }
                    } else {
                        sourceData = sampleResults.find(r => r.windDirection == azimuth);
                    }

                    if (sourceData && sourceData.siteInfo) {
                        // Determine which coordinate this element represents by inspecting its label sibling
                        const labelSpan = element.previousElementSibling;
                        if (!labelSpan || labelSpan.tagName !== 'SPAN') break;

                        const labelText = labelSpan.textContent || '';
                        const isLatitude = /Latitude/i.test(labelText);
                        const isLongitude = /Longitude/i.test(labelText);
                        if (!isLatitude && !isLongitude) break;

                        const isCrest = /Crest/i.test(labelText);
                        let coord;
                        if (isCrest) {
                            coord = isLatitude ? sourceData.siteInfo.crestCoords.lat : sourceData.siteInfo.crestCoords.lon;
                        } else {
                            coord = isLatitude ? sourceData.siteInfo.structCoords.lat : sourceData.siteInfo.structCoords.lon;
                        }

                        element.textContent = formatSingleCoordinate(coord, isLatitude ? 'lat' : 'lon');
                    }
                    break;
                }
            });
        }
        function formatSingleCoordinate(value, type) {
            if (typeof value !== 'number') return 'N/A';
            if (state.coordinateFormat === 'dms') {
                const dirs = type === 'lat' ? 'NS' : 'EW';
                const absDd = Math.abs(value);
                const d = Math.floor(absDd);
                const m = Math.floor((absDd - d) * 60);
                const s = (((absDd - d) * 60 - m) * 60).toFixed(2);
                const dir = value >= 0 ? dirs[0] : dirs[1];
                return `${d}° ${m}' ${s}" ${dir}`;
            }
            return `${value.toFixed(6)}°`;
        }

        // =================================================================================
        // DYNAMIC RENDERING FUNCTIONS
        // =================================================================================

        function renderControlPanel(results) {
            const container = document.getElementById('control-panel-container');
            const includedResults = results.filter(r => r.status === 'success' && r.isIncluded);
            const excludedResults = results.filter(r => r.status === 'success' && !r.isIncluded);
            const collapsedCount = results.filter(r => r.status === 'success' && r.isCollapsed).length;
            const visibleCount = results.filter(r => r.status === 'success' && !r.isCollapsed).length;
            
            // Check current section states across visible cards
            const visibleCards = document.querySelectorAll('.kzt-card:not([style*="display: none"])');
            let summariesVisible = 0, matrixVisible = 0, graphsVisible = 0;
            
            visibleCards.forEach(card => {
                const summariesSection = card.querySelector('[data-section-key="summaries"] + .collapsible-content');
                const matrixSection = card.querySelector('[data-section-key="matrix"] + .collapsible-content');
                const graphsSection = card.querySelector('[data-section-key="graph"] + .collapsible-content');
                
                if (summariesSection && !summariesSection.classList.contains('is-collapsed')) summariesVisible++;
                if (matrixSection && !matrixSection.classList.contains('is-collapsed')) matrixVisible++;
                if (graphsSection && !graphsSection.classList.contains('is-collapsed')) graphsVisible++;
            });
                // Check section states for expand/collapse button
            let expandedSections = 0;
            let totalVisibleSections = 0;
            
            visibleCards.forEach(card => {
                const sections = card.querySelectorAll('.card-section-header[data-section-key]');
                sections.forEach(sectionHeader => {
                    const content = sectionHeader.nextElementSibling;
                    if (content) {
                        totalVisibleSections++;
                        if (!content.classList.contains('is-collapsed')) {
                            expandedSections++;
                        }
                    }
                });
            });
            
            const isExpandMode = expandedSections <= totalVisibleSections / 2;
            
            container.innerHTML = `
                <div class="control-panel" id="control-panel">
                    <div class="control-panel-header">
                        <div class="control-panel-title">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4"></path>
                            </svg>
                            Visualization Controls
                        </div>
                        <div class="flex items-center gap-4">
                            <div class="status-indicator status-docked">
                                <span class="w-2 h-2 bg-current rounded-full"></span>
                                ${collapsedCount} Docked
                            </div>
                            <div class="status-indicator status-visible">
                                <span class="w-2 h-2 bg-current rounded-full"></span>
                                ${visibleCount} Visible
                            </div>
                            <div class="status-indicator ${excludedResults.length > 0 ? 'status-hidden' : 'status-visible'}">
                                <span class="w-2 h-2 bg-current rounded-full"></span>
                                ${includedResults.length} Included
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-panel-grid grid-cols-3">
                        <!-- Card Management -->
                        <div class="control-group">
                            <div class="control-group-title">Card Management</div>
                            <div class="control-column">
                                <button class="control-btn control-btn-primary dock-toggle-btn" data-mode="${visibleCount > 0 ? 'dock' : 'undock'}">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        ${visibleCount > 0 ? 
                                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>' :
                                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V8m0 0h-4m4 0l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5 5"></path>'
                                        }
                                    </svg>
                                    ${visibleCount > 0 ? 'Dock All' : 'Undock All'}
                                </button>
                                <button class="control-btn control-btn-secondary include-toggle-btn" data-mode="${excludedResults.length > 0 ? 'include' : 'exclude'}">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        ${excludedResults.length > 0 ?
                                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>' :
                                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path>'
                                        }
                                    </svg>
                                    ${excludedResults.length > 0 ? 'Include All' : 'Exclude All'}
                                </button>
                                <button class="control-btn control-btn-secondary expand-collapse-toggle-btn ${visibleCount === 0 ? 'opacity-50 pointer-events-none' : ''}" ${visibleCount === 0 ? 'disabled' : ''}>
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        ${isExpandMode ?
                                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16l-4-4m0 0l4-4m-4 4h18m-6-4l4 4m0 0l-4 4"></path>' :
                                            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3m14-4l-4-4m0 0l4 4"></path>'
                                        }
                                    </svg>
                                    ${isExpandMode ? 'Expand All' : 'Collapse All'}
                                </button>
                            </div>
                        </div>

                        <!-- Section Visibility -->
                        <div class="control-group ${visibleCount === 0 ? 'opacity-50 pointer-events-none' : ''}">
                            <div class="control-group-title">Section Visibility</div>
                            <div class="control-column">
                                <button class="control-btn control-btn-secondary toggle-summaries-btn" data-state="${summariesVisible > 0 ? 'visible' : 'hidden'}" ${visibleCount === 0 ? 'disabled' : ''}>
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                    </svg>
                                    ${summariesVisible > 0 ? 'Hide' : 'Show'} Summaries
                                </button>
                                <button class="control-btn control-btn-secondary toggle-matrix-btn" data-state="${matrixVisible > 0 ? 'visible' : 'hidden'}" ${visibleCount === 0 ? 'disabled' : ''}>
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0V4a1 1 0 011-1h4a1 1 0 011 1v16a1 1 0 01-1 1H4a1 1 0 01-1-1z"></path>
                                    </svg>
                                    ${matrixVisible > 0 ? 'Hide' : 'Show'} Matrix
                                </button>
                                <button class="control-btn control-btn-secondary toggle-graphs-btn" data-state="${graphsVisible > 0 ? 'visible' : 'hidden'}" ${visibleCount === 0 ? 'disabled' : ''}>
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                                    </svg>
                                    ${graphsVisible > 0 ? 'Hide' : 'Show'} Graphs
                                </button>
                            </div>
                        </div>

               <!-- View Options -->
                        <div class="control-group">
                            <div class="control-group-title">View Options</div>
                            <div class="control-column">
                                <div class="control-toggle">
                                    <span class="control-toggle-label">Mirror Sections</span>
                                    <input type="checkbox" id="control-mirror-sections-toggle" ${state.mirrorSectionsLg ? 'checked' : ''}>
                                </div>
                                <div class="control-toggle">
                                    <span class="control-toggle-label">Animation Speed</span>
                     <input type="range" id="control-animation-speed-slider" class="control-slider-inline" 
                         min="0" max="5" step="1" value="${state.animationSpeed}" title="Animation speed: 0 = instant, 5 = slowest">
                     <span class="speed-value">${Number(state.animationSpeed).toFixed(1)}x</span>
                                </div>
                                <button class="control-btn control-btn-secondary reset-defaults-btn">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                    Reset to Defaults
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderManagerCard() {
            const container = document.getElementById('manager-card-container');
            container.innerHTML = `<div class="manager-card" id="manager-card">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-bold text-slate-800">Global Controls</h3>
                </div>
                <div class="manager-controls-grid">
                    <div class="control-group">
                        <label for="global-code-select">Code</label>
                        <select id="global-code-select" class="rounded-md">
                            <option value="asce7-10">ASCE 7-10</option>
                            <option value="asce7-16" selected>ASCE 7-16</option>
                            <option value="asce7-22">ASCE 7-22</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="global-exposure-select">Exposure</label>
                        <select id="global-exposure-select" class="rounded-md">
                            <option value="by-azimuth" selected>By Azimuth</option>
                            <option value="B">B (Global)</option>
                            <option value="C">C (Global)</option>
                            <option value="D">D (Global)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="global-topo-select">Topography</label>
                        <select id="global-topo-select" class="rounded-md">
                            <option value="by-azimuth" selected>By Azimuth</option>
                            <option value="none">None (Global)</option>
                            <option value="ridge2D">2D Ridge (Global)</option>
                            <option value="escarp">2D Escarpment (Global)</option>
                            <option value="hill3D">3D Hill (Global)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="global-z-value">Height Above Ground (z)</label>
                        <div class="flex">
                            <input type="text" id="global-z-value" value="0.0" class="w-full text-sm rounded-none rounded-l-md focus:z-10 focus:ring-indigo-500 focus:border-indigo-500">
                            <select id="global-z-unit" class="border-l-0 bg-slate-50 text-sm rounded-none rounded-r-md hover:bg-slate-100 focus:z-10 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                <option selected>ft</option>
                                <option>m</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>`;
        }

        function renderControllingCaseCard(results) {
            const container = document.getElementById('controlling-case-container');
            const includedSuccessResults = results.filter(r => r.status === 'success' && r.isIncluded);
            
            // Check if this is just a content state change vs full card re-render
            const existingCard = container.querySelector('.controlling-case-card');
            const hasContent = includedSuccessResults.length > 0;
            
            if (!existingCard) {
                // First render - create the card structure
                container.innerHTML = `
                    <div class="controlling-case-card" id="controlling-case-card">
                        <div class="card-header">
                            <strong class="controlling-case-title">Controlling Case</strong>
                            <div class="final-kzt-display" style="display: none;">
                                Final K<sub>zt</sub>: <strong class="final-kzt-value">0.000</strong>
                            </div>
                        </div>
                        <div class="card-content">
                            <div class="controlling-case-content collapsible-content ${hasContent ? '' : 'is-collapsed'}">
                                <div class="no-data-message" style="display: ${hasContent ? 'none' : 'block'};">
                                    <!-- Short status only: user-visible even when content is collapsed -->
                                    <p class="text-slate-600">No azimuths are currently included.</p>
                                </div>
                                <div class="controlling-data-container" style="display: ${hasContent ? 'block' : 'none'};">
                                    <div class="info-container"></div>
                                </div>
                            </div>
                        </div>
                    </div>`;
                // Track initial expansion state on the card element
                const firstCard = container.querySelector('.controlling-case-card');
                if (firstCard) firstCard.dataset.expanded = String(hasContent);
            }
            
            // Update content with animation
            const card = container.querySelector('.controlling-case-card');
            const titleElement = card.querySelector('.controlling-case-title');
            const kztDisplay = card.querySelector('.final-kzt-display');
            const noDataMessage = card.querySelector('.no-data-message');
            const dataContainer = card.querySelector('.controlling-data-container');
            const infoContainer = card.querySelector('.info-container');
            const wrapper = card.querySelector('.controlling-case-content');
            const prevExpanded = card.dataset.expanded ? card.dataset.expanded === 'true' : null;
            
            if (!hasContent) {
                // No data: show short title message so user sees issue even when card is collapsed
                titleElement.textContent = 'Controlling Case: None — no azimuths are currently included';
                kztDisplay.style.display = 'none';
                // If the section was previously expanded, defer hiding inner content
                // until after the collapse animation so we can measure height and
                // animate smoothly. If it was already collapsed (or first render),
                // hide immediately.
                if (prevExpanded === true) {
                    // keep dataContainer visible for measurement; still show the no-data message
                    if (noDataMessage) noDataMessage.style.display = 'block';
                    // leave dataContainer visible so collapse animation can measure height
                } else {
                    // Toggle visible content instantly (no inner animations)
                    if (noDataMessage) noDataMessage.style.display = 'block';
                    if (dataContainer) dataContainer.style.display = 'none';
                }
            } else {
                // We have controlling case data
                const controllingCase = includedSuccessResults.reduce((max, current) => 
                    current.defaultKzt > max.defaultKzt ? current : max);
                
                // Update header information
                titleElement.innerHTML = `Azimuth ${controllingCase.windDirection}° (Controlling Case, Highest K<sub>zt</sub>)`;
                kztDisplay.className = 'final-kzt-display !bg-violet-100 !text-violet-800';
                kztDisplay.style.display = 'flex';
                card.querySelector('.final-kzt-value').textContent = controllingCase.defaultKzt.toFixed(3);
                
                // Prepare detailed content
                infoContainer.innerHTML = `
                    <div class="info-section">
                        <h5 class="section-title">Site Location</h5>
                        <div class="info-grid">
                            <span>Crest Latitude:</span><strong class="coord-toggle">${formatSingleCoordinate(controllingCase.siteInfo.crestCoords.lat, 'lat')}</strong>
                            <span>Crest Longitude:</span><strong class="coord-toggle">${formatSingleCoordinate(controllingCase.siteInfo.crestCoords.lon, 'lon')}</strong>
                            <span>Crest Elevation:</span><strong class="unit-toggle" data-param-key="crestElev">${convertFromFt(controllingCase.siteInfo.crestElev, state.units.crestElev).toFixed(2)} ${state.units.crestElev}</strong>
                            <span>Struct. Latitude:</span><strong class="coord-toggle">${formatSingleCoordinate(controllingCase.siteInfo.structCoords.lat, 'lat')}</strong>
                            <span>Struct. Longitude:</span><strong class="coord-toggle">${formatSingleCoordinate(controllingCase.siteInfo.structCoords.lon, 'lon')}</strong>
                            <span>Structure Elev:</span><strong class="unit-toggle" data-param-key="structElev">${convertFromFt(controllingCase.siteInfo.structElev, state.units.structElev).toFixed(2)} ${state.units.structElev}</strong>
                            <span>Exposure Category:</span><strong>${controllingCase.siteInfo.exposure}</strong>
                            <span>Topo Feature:</span><strong>${controllingCase.siteInfo.topoFeature}</strong>
                        </div>
                    </div>
                    <div class="info-section">
                        <h5 class="section-title">Selection Summary</h5>
                        <div class="info-grid">
                            <span>Selec. L:</span><strong class="unit-toggle" data-param-key="L">${convertFromFt(controllingCase.selectionSummary.L, state.units.L).toFixed(2)} ${state.units.L}</strong>
                            <span>Top:</span><strong class="unit-toggle" data-param-key="Top">${convertFromFt(controllingCase.selectionSummary.Top, state.units.Top).toFixed(2)} ${state.units.Top}</strong>
                            <span>Mid:</span><strong class="unit-toggle" data-param-key="Mid">${convertFromFt(controllingCase.selectionSummary.Mid, state.units.Mid).toFixed(2)} ${state.units.Mid}</strong>
                            <span>Bottom:</span><strong class="unit-toggle" data-param-key="Bottom">${convertFromFt(controllingCase.selectionSummary.Bottom, state.units.Bottom).toFixed(2)} ${state.units.Bottom}</strong>
                            <span>Dist to Mid:</span><strong class="unit-toggle" data-param-key="distToMid">${convertFromFt(controllingCase.selectionSummary.distToMid, state.units.distToMid).toFixed(2)} ${state.units.distToMid}</strong>
                            <span>Slope:</span><strong>${controllingCase.selectionSummary.slopePct.toFixed(2)}%</strong>
                        </div>
                    </div>
                    <div class="info-section">
                        <h5 class="section-title">Kzt Parameters</h5>
                        <div class="info-grid">
                            <span>H:</span><strong class="unit-toggle" data-param-key="H">${convertFromFt(controllingCase.kztParams.H, state.units.H).toFixed(1)} ${state.units.H}</strong>
                            <span>Lh:</span><strong class="unit-toggle" data-param-key="Lh">${convertFromFt(controllingCase.kztParams.Lh, state.units.Lh).toFixed(1)} ${state.units.Lh}</strong>
                            <span>x:</span><strong class="unit-toggle" data-param-key="x">${convertFromFt(controllingCase.kztParams.x, state.units.x).toFixed(1)} ${state.units.x}</strong>
                            <span>z:</span><strong class="unit-toggle" data-param-key="z">${convertFromFt(controllingCase.kztParams.z, state.units.z).toFixed(1)} ${state.units.z}</strong>
                            <span>&mu;:</span><strong>${controllingCase.kztParams.mu.toFixed(3)}</strong>
                            <span>&gamma;:</span><strong>${controllingCase.kztParams.gamma.toFixed(3)}</strong>
                            <span>K1:</span><strong>${controllingCase.kztParams.K1.toFixed(3)}</strong>
                            <span>K2:</span><strong>${controllingCase.kztParams.K2.toFixed(3)}</strong>
                            <span>K3:</span><strong>${controllingCase.kztParams.K3.toFixed(3)}</strong>
                        </div>
                    </div>`;
                
                // Toggle visible content instantly (no inner animations)
                noDataMessage.style.display = 'none';
                dataContainer.style.display = 'block';
            }

            // Animate only the container when expansion state changes (match section behavior)
            const shouldExpand = hasContent;
            if (prevExpanded !== null && prevExpanded !== shouldExpand) {
                if (shouldExpand) {
                    // EXPAND like expandSection
                    wrapper.classList.remove('is-collapsed');
                    // Measure target height
                    wrapper.style.maxHeight = 'none';
                    const target = wrapper.scrollHeight;
                    wrapper.style.maxHeight = '0px';
                    requestAnimationFrame(() => {
                        wrapper.style.maxHeight = target + 'px';
                    });
                    // Observe for dynamic height while expanded
                    const existingRo = roMap.get(wrapper);
                    if (existingRo) existingRo.disconnect();
                    const ro = new ResizeObserver(() => {
                        if (!wrapper.classList.contains('is-collapsed')) {
                            wrapper.style.maxHeight = wrapper.scrollHeight + 'px';
                        }
                    });
                    ro.observe(wrapper);
                    roMap.set(wrapper, ro);
                } else {
                    // COLLAPSE - robust sequence: measure current height, animate to 0,
                    // then hide inner content after transitionend. This avoids abrupt jumps
                    // and ensures the CSS transition duration (from --section-transition-duration)
                    // is respected.
                    const ro = roMap.get(wrapper);
                    if (ro) { ro.disconnect(); roMap.delete(wrapper); }

                    // Ensure the element has the full current height as start point
                    // remove any 'none' to get an accurate scrollHeight
                    wrapper.style.maxHeight = 'none';
                    const startHeight = wrapper.scrollHeight;
                    // If there's nothing to animate, do an instant hide
                    const root = document.documentElement;
                    const sectionMs = parseFloat(getComputedStyle(root).getPropertyValue('--section-transition-duration')) || 0;

                    // Prepare to animate from startHeight -> 0
                    wrapper.style.maxHeight = startHeight + 'px';
                    // Force a reflow before changing to 0
                    // (read offsetHeight to flush layout)
                    void wrapper.offsetHeight;

                    let cleaned = false;
                    const cleanup = () => {
                        if (cleaned) return;
                        cleaned = true;
                        // After collapse, mark collapsed class and clear inline maxHeight so
                        // CSS can handle future transitions and ResizeObserver can set heights.
                        wrapper.classList.add('is-collapsed');
                        wrapper.style.maxHeight = '';
                        // Hide inner content to avoid focusable elements remaining visible
                        const noData = card.querySelector('.no-data-message');
                        const dataCont = card.querySelector('.controlling-data-container');
                        if (noData) noData.style.display = 'block';
                        if (dataCont) dataCont.style.display = 'none';
                    };

                    // If duration is zero or very small, skip animation and cleanup instantly
                    if (sectionMs <= 0) {
                        // Instant collapse
                        wrapper.classList.add('is-collapsed');
                        wrapper.style.maxHeight = '';
                        const noData = card.querySelector('.no-data-message');
                        const dataCont = card.querySelector('.controlling-data-container');
                        if (noData) noData.style.display = 'block';
                        if (dataCont) dataCont.style.display = 'none';
                    } else {
                        // Attach transitionend to know when collapse finished
                        const onEnd = (ev) => {
                            if (ev.propertyName === 'max-height') {
                                wrapper.removeEventListener('transitionend', onEnd);
                                cleanup();
                            }
                        };
                        wrapper.addEventListener('transitionend', onEnd);

                        // Start animation to 0
                        requestAnimationFrame(() => {
                            wrapper.style.maxHeight = '0px';
                        });

                        // Safety fallback: if transitionend doesn't fire, clean up after duration + 50ms
                        setTimeout(() => {
                            cleanup();
                            wrapper.removeEventListener('transitionend', onEnd);
                        }, sectionMs + 50);
                    }
                }
            }

            // Persist state
            card.dataset.expanded = String(shouldExpand);
        }
        
        
        function renderCollapsedBar(results) {
            const container = document.getElementById('collapsed-bar-container');
            const collapsedResults = results.filter(r => r.status === 'success' && r.isCollapsed);
            const wasEmpty = !document.getElementById('collapsed-bar') || document.getElementById('collapsed-bar').children.length === 0;
            
            if (collapsedResults.length === 0) { 
                container.innerHTML = ''; 
                return; 
            }
            
            let badgesHtml = collapsedResults.map((r, index) => {
                const color = getAzimuthColor(r.windDirection);
                const isExcluded = !r.isIncluded;
                return `<div class="collapsed-badge restore-btn ${color.bg} ${color.text} ${isExcluded ? 'line-through opacity-70' : ''}" data-azimuth="${r.windDirection}" style="animation-delay: ${index * getAnimationDelay(50)}ms"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V8m0 0h-4m4 0l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5 5"></path></svg>Azimuth ${r.windDirection}°</div>`;
            }).join('');
            
            const dockClass = wasEmpty && collapsedResults.length > 0 ? 'dock-appearing' : 
                             (!wasEmpty && collapsedResults.length > 0 ? 'dock-updating' : '');
            
            container.innerHTML = `<div id="collapsed-bar" class="${dockClass}"><div class="flex items-center gap-2 flex-wrap"><span class="text-sm font-semibold text-slate-700 mr-2">Collapsed:</span>${badgesHtml}</div></div>`;
            
            // Add entering animation to new badges
            if (!wasEmpty) {
                setTimeout(() => {
                    const newBadges = container.querySelectorAll('.collapsed-badge:not(.badge-entered)');
                    newBadges.forEach(badge => {
                        badge.classList.add('badge-entering');
                        badge.classList.add('badge-entered');
                    });
                }, 50);
            }
        }

        function renderAzimuthCards(results) {
            const container = document.getElementById('card-container');
            // Preserve current expanded/collapsed states to avoid jump on re-render
            const preservedStates = new Map();
            container.querySelectorAll('.kzt-card').forEach(card => {
                const az = parseInt(card.dataset.azimuth, 10);
                if (!isNaN(az)) {
                    const s = {
                        summaries: false,
                        matrix: false,
                        graph: false,
                    };
                    ['summaries','matrix','graph'].forEach(key => {
                        const header = card.querySelector(`[data-section-key="${key}"]`);
                        const content = header ? header.nextElementSibling : null;
                        if (content) s[key] = !content.classList.contains('is-collapsed');
                    });
                    preservedStates.set(az, s);
                }
            });
            
            const visibleCards = results.filter(r => !r.isCollapsed);
            let cardsHtml = '';
            for (const r of visibleCards) {
                if (r.status === 'success') {
                    const ps = preservedStates.get(r.windDirection) || { summaries: true, matrix: false, graph: false };
                    cardsHtml += `
                        <div class="kzt-card ${!r.isIncluded ? 'is-excluded' : ''}" id="kzt-card-${r.windDirection}" data-azimuth="${r.windDirection}">
                            <div class="card-header">
                                <div class="flex items-center gap-3">
                                    <button class="collapse-btn p-1 rounded-full hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-indigo-400"><svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                                    <strong>Azimuth: ${r.windDirection}°</strong>
                                </div>
                                <div class="flex items-center gap-4">
                                    <div class="flex items-center gap-2"><input type="checkbox" id="include-azimuth-${r.windDirection}" data-azimuth="${r.windDirection}" class="include-checkbox h-4 w-4 rounded border-slate-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer" ${r.isIncluded ? 'checked' : ''}><label for="include-azimuth-${r.windDirection}" class="text-sm font-medium text-slate-700 cursor-pointer select-none">Include</label></div>
                                    <div class="final-kzt-display">Final K<sub>zt</sub>: <strong class="final-kzt-value">${r.defaultKzt.toFixed(3)}</strong></div>
                                </div>
                            </div>
                            <div class="card-content">
                                <!-- Summaries Section -->
                                <div class="card-section-header section-collapse-btn" data-section-key="summaries"><span class="card-section-title">Summaries</span><svg class="w-5 h-5 text-slate-500 card-section-toggle ${ps.summaries ? '' : 'is-collapsed'}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></div>
                                <div class="collapsible-content ${ps.summaries ? '' : 'is-collapsed'}"><div>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                        <div class="info-section"><h5 class="section-title">Selection Summary</h5><div class="info-grid"><span>Selec. L:</span><strong class="unit-toggle" data-param-key="L">${convertFromFt(r.selectionSummary.L, state.units.L).toFixed(2)} ${state.units.L}</strong><span>Top:</span><strong class="unit-toggle" data-param-key="Top">${convertFromFt(r.selectionSummary.Top, state.units.Top).toFixed(2)} ${state.units.Top}</strong><span>Mid:</span><strong class="unit-toggle" data-param-key="Mid">${convertFromFt(r.selectionSummary.Mid, state.units.Mid).toFixed(2)} ${state.units.Mid}</strong><span>Bottom:</span><strong class="unit-toggle" data-param-key="Bottom">${convertFromFt(r.selectionSummary.Bottom, state.units.Bottom).toFixed(2)} ${state.units.Bottom}</strong><span>Dist to Mid:</span><strong class="unit-toggle" data-param-key="distToMid">${convertFromFt(r.selectionSummary.distToMid, state.units.distToMid).toFixed(2)} ${state.units.distToMid}</strong><span>Slope:</span><strong>${r.selectionSummary.slopePct.toFixed(2)}%</strong></div></div>
                                        <div class="info-section"><h5 class="section-title">Kzt Parameters</h5><div class="info-grid"><span>H:</span><strong class="unit-toggle" data-param-key="H">${convertFromFt(r.kztParams.H, state.units.H).toFixed(1)} ${state.units.H}</strong><span>Lh:</span><strong class="unit-toggle" data-param-key="Lh">${convertFromFt(r.kztParams.Lh, state.units.Lh).toFixed(1)} ${state.units.Lh}</strong><span>x:</span><strong class="unit-toggle" data-param-key="x">${convertFromFt(r.kztParams.x, state.units.x).toFixed(1)} ${state.units.x}</strong><span>z:</span><strong class="unit-toggle" data-param-key="z">${convertFromFt(r.kztParams.z, state.units.z).toFixed(1)} ${state.units.z}</strong><span>&mu;:</span><strong>${r.kztParams.mu.toFixed(3)}</strong><span>&gamma;:</span><strong>${r.kztParams.gamma.toFixed(3)}</strong><span>K1:</span><strong>${r.kztParams.K1.toFixed(3)}</strong><span>K2:</span><strong>${r.kztParams.K2.toFixed(3)}</strong><span>K3:</span><strong>${r.kztParams.K3.toFixed(3)}</strong></div></div>
                                    </div>
                                </div></div>
                                <!-- Matrix Section -->
                                <div class="card-section-header section-collapse-btn" data-section-key="matrix"><span class="card-section-title">Kzt Matrix</span><svg class="w-5 h-5 text-slate-500 card-section-toggle ${ps.matrix ? '' : 'is-collapsed'}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></div>
                                <div class="collapsible-content ${ps.matrix ? '' : 'is-collapsed'}"><div>
                                    <table class="kzt-matrix-table">
                                        <thead><tr><th>Topo Shape</th><th>Exp. B</th><th>Exp. C</th><th>Exp. D</th></tr></thead>
                                        <tbody>${Object.entries(r.kztMatrix).map(([shape, exposures]) => `<tr><td>${shape.replace('ridge2D', '2D Ridge').replace('escarp', '2D Escarpment').replace('hill3D', '3D Hill').replace('none', 'None')}</td>${Object.entries(exposures).map(([exp, val]) => `<td><label class="radio-label"><input type="radio" name="kzt-override-${r.windDirection}" value="${val.toFixed(4)}" data-topo="${shape}" data-exp="${exp}" ${r.defaultShape === shape && r.defaultExposure === exp ? 'checked' : ''}>${val.toFixed(3)}</label></td>`).join('')}</tr>`).join('')}</tbody>
                                    </table>
                                </div></div>
                                <!-- Graph Section -->
                                <div class="card-section-header section-collapse-btn" data-section-key="graph">
                                    <span class="card-section-title">Elevation Profile</span>
                                    <svg class="w-5 h-5 text-slate-500 card-section-toggle ${ps.graph ? '' : 'is-collapsed'}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                </div>
                                <div class="collapsible-content ${ps.graph ? '' : 'is-collapsed'}"><div>
                                    <div class="chart-container">
                                        <canvas id="chart-canvas-${r.windDirection}"></canvas>
                                        <div class="chart-hover-hint">Double right-click to access chart tools</div>
                                        <div class="chart-overlay">
                                            <div class="chart-crosshair">
                                                <div class="chart-crosshair-line chart-crosshair-vertical"></div>
                                                <div class="chart-crosshair-line chart-crosshair-horizontal"></div>
                                            </div>
                                            <div class="chart-preview-point"></div>
                                            <div class="chart-preview-segment"></div>
                                        </div>
                                        <div class="chart-coordinates">
                                            <div class="coord-x">X: <span>0</span></div>
                                            <div class="coord-y">Y: <span>0</span></div>
                                        </div>
                                        <div class="chart-tool-status">
                                            <svg class="tool-status-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                                            </svg>
                                            <span class="status-text">Click to add point</span>
                                        </div>
                                    </div>
                                    <!-- R/D Switch relocated below chart as part of description -->
                                    <div class="chart-rd-selector-inline">
                                        <span class="view-label">View:</span>
                                        <button class="chart-view-toggle-btn ${state.profileView === 'radial' ? 'active' : ''}" data-view="radial" title="Radial View">R</button>
                                        <button class="chart-view-toggle-btn ${state.profileView === 'diametral' ? 'active' : ''}" data-view="diametral" title="Diametral View">D</button>
                                    </div>
                                </div></div>
                            </div>
                        </div>`;
                } else if (r.status === 'skipped') {
                    cardsHtml += `<div class="kzt-card-skipped lg:col-span-2">${r.reason}</div>`;
                }
            }
            container.innerHTML = cardsHtml;

            // If any graphs are initially expanded, render them now
            setTimeout(() => {
                document.querySelectorAll('.kzt-card').forEach(card => {
                    const graphContent = card.querySelector('[data-section-key="graph"] + .collapsible-content');
                    if (graphContent && !graphContent.classList.contains('is-collapsed')) {
                        const azimuth = card.dataset.azimuth;
                        if (azimuth) renderSingleChart(parseInt(azimuth));
                    }
                });

                // Add event listeners for profile view toggle buttons (both old and new chart overlay buttons)
                document.querySelectorAll('.view-toggle-btn, .chart-view-toggle-btn').forEach(btn => {
                    // Initialize active state based on current global state
                    const viewType = btn.dataset.view;
                    if (viewType === state.profileView) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                    
                    btn.addEventListener('click', (e) => {
                        const viewType = e.target.dataset.view;
                        
                        // Update global state
                        state.profileView = viewType;
                        
                        // Update active state for all toggle buttons across all cards (both types)
                        document.querySelectorAll('.view-toggle-btn, .chart-view-toggle-btn').forEach(b => {
                            if (b.dataset.view === viewType) {
                                b.classList.add('active');
                            } else {
                                b.classList.remove('active');
                            }
                        });
                        
                        // Re-render all visible charts
                        renderCharts();
                    });
                });

                // Initialize view states from storage
                initializeViewStates();

                // Chart Display Mode Controls
                setupChartDisplayModes();

                // Enhanced chart mouse event handlers
                setupChartMouseHandlers();
                
                // Setup hover hints for chart tool access
                setupChartHoverHints();
            }, 50);
        }
        
        // Setup hover hints for chart tool access
        function setupChartHoverHints() {
            document.querySelectorAll('.chart-container').forEach(container => {
                const hint = container.querySelector('.chart-hover-hint');
                if (!hint) return;
                
                let hoverTimer = null;
                
                container.addEventListener('mouseenter', () => {
                    // Delay showing the hint by 1.5 seconds
                    hoverTimer = setTimeout(() => {
                        hint.classList.add('delayed-show');
                    }, 1500);
                });
                
                container.addEventListener('mouseleave', () => {
                    // Clear timer and hide hint immediately
                    if (hoverTimer) {
                        clearTimeout(hoverTimer);
                        hoverTimer = null;
                    }
                    hint.classList.remove('delayed-show');
                });
                
                // Hide hint if user interacts with the chart
                const canvas = container.querySelector('canvas');
                if (canvas) {
                    canvas.addEventListener('click', () => {
                        hint.classList.remove('delayed-show');
                        if (hoverTimer) {
                            clearTimeout(hoverTimer);
                            hoverTimer = null;
                        }
                    });
                }
            });
        }
        
        // Enhanced tool state management functions
        function resetAllToolStates() {
            // Clear any pending operations
            state.chartTool.pending = null;
            
            // Hide all tool overlays
            document.querySelectorAll('.chart-preview-point, .chart-preview-segment').forEach(el => {
                el.classList.remove('visible');
            });
            
            // Remove all chart container state classes
            document.querySelectorAll('.chart-container').forEach(container => {
                container.classList.remove('tool-active', 'tool-point-active', 'tool-segment-active', 'tool-segment-pending');
            });
        }
        
        function updateToolVisualStates() {
            const az = state.chartTool.activeAzimuth;
            if (!az) return;
            
            const container = document.querySelector(`#chart-canvas-${az}`)?.closest('.chart-container');
            if (!container) return;
            
            container.classList.add('tool-active');
            
            if (state.chartTool.mode === 'point') {
                container.classList.add('tool-point-active');
            } else if (state.chartTool.mode === 'segment') {
                container.classList.add('tool-segment-active');
                if (state.chartTool.pending) {
                    container.classList.add('tool-segment-pending');
                }
            }
        }
        
        function updateChartContainerStates() {
            document.querySelectorAll('.chart-container').forEach(container => {
                const canvas = container.querySelector('canvas');
                if (!canvas) return;
                
                const azMatch = canvas.id.match(/chart-canvas-(\d+)/);
                if (!azMatch) return;
                
                const az = parseInt(azMatch[1]);
                const isActive = state.chartTool.activeAzimuth === az;
                
                container.classList.toggle('tool-active', isActive);
                container.classList.toggle('tool-point-active', isActive && state.chartTool.mode === 'point');
                container.classList.toggle('tool-segment-active', isActive && state.chartTool.mode === 'segment');
                container.classList.toggle('tool-segment-pending', isActive && state.chartTool.mode === 'segment' && state.chartTool.pending);
            });
        }
        
        function updateAllToolButtons() {
            // Update point dropdown buttons
            document.querySelectorAll('.tool-point-main').forEach(btn => {
                const az = parseInt(btn.dataset.az, 10);
                const isActive = state.chartTool.mode === 'point' && state.chartTool.activeAzimuth === az;
                btn.classList.toggle('active', isActive);
            });
            
            // Update legacy point buttons (if any exist)
            document.querySelectorAll('.tool-point').forEach(btn => {
                const az = parseInt(btn.dataset.az, 10);
                const isActive = state.chartTool.mode === 'point' && state.chartTool.activeAzimuth === az;
                btn.classList.toggle('active', isActive);
            });
            
            // Update segment dropdown buttons
            document.querySelectorAll('.tool-segment-main').forEach(btn => {
                const az = parseInt(btn.dataset.az, 10);
                const isActive = state.chartTool.mode === 'segment' && state.chartTool.activeAzimuth === az;
                const isPending = isActive && state.chartTool.pending !== null;
                
                btn.classList.toggle('active', isActive);
                btn.classList.toggle('pending', isPending);
            });
            
            // Update legacy segment buttons (if any exist)
            document.querySelectorAll('.tool-seg').forEach(btn => {
                const az = parseInt(btn.dataset.az, 10);
                const isActive = state.chartTool.mode === 'segment' && state.chartTool.activeAzimuth === az;
                const isPending = isActive && state.chartTool.pending !== null;
                
                btn.classList.toggle('active', isActive);
                btn.classList.toggle('pending', isPending);
            });
        }
        
        function showToolStatus(az, mode) {
            const container = document.querySelector(`#chart-canvas-${az}`)?.closest('.chart-container');
            if (!container) return;
            
            const status = container.querySelector('.chart-tool-status');
            if (!status) return;
            
            status.className = `chart-tool-status visible mode-${mode}`;
            updateToolStatus();
        }
        
        function updateToolStatus() {
            if (!state.chartTool.activeAzimuth) return;
            
            const container = document.querySelector(`#chart-canvas-${state.chartTool.activeAzimuth}`)?.closest('.chart-container');
            if (!container) return;
            
            const status = container.querySelector('.chart-tool-status');
            const statusText = container.querySelector('.status-text');
            const statusIcon = container.querySelector('.tool-status-icon path');
            
            if (!status || !statusText || !statusIcon) return;
            
            if (state.chartTool.mode === 'point') {
                const pointType = state.chartTool.pointType.replace('-', ' ');
                statusText.textContent = `Click to add ${pointType} point`;
                statusIcon.setAttribute('d', 'M12 6v6m0 0v6m0-6h6m-6 0H6');
            } else if (state.chartTool.mode === 'segment') {
                if (state.chartTool.pending) {
                    statusText.textContent = 'Click to complete segment';
                    status.classList.add('pending');
                } else {
                    statusText.textContent = `Click to start ${state.chartTool.segmentClass} segment`;
                    status.classList.remove('pending');
                }
                statusIcon.setAttribute('d', 'M8 12h8m-8 0V8m0 4v4m8-4V8m0 4v4');
            }
        }
        
        function hideAllToolStatuses() {
            document.querySelectorAll('.chart-tool-status').forEach(status => {
                status.classList.remove('visible');
            });
        }
        
        function clearAnnotationsWithAnimation(az) {
            state.annotationsByAzimuth[az] = { points: [], segments: [], visible: true };
            if (chartInstances[az]) chartInstances[az].update();
        }
        
        function setupChartMouseHandlers() {
            // Add enhanced mouse event handlers to all chart containers
            document.querySelectorAll('.chart-container').forEach(container => {
                const canvas = container.querySelector('canvas');
                const overlay = container.querySelector('.chart-overlay');
                const crosshair = container.querySelector('.chart-crosshair');
                const previewPoint = container.querySelector('.chart-preview-point');
                const previewSegment = container.querySelector('.chart-preview-segment');
                const coordinates = container.querySelector('.chart-coordinates');
                
                if (!canvas || !overlay) return;
                
                const azMatch = canvas.id.match(/chart-canvas-(\d+)/);
                if (!azMatch) return;
                const az = parseInt(azMatch[1]);
                
                // Mouse enter - show interactive elements
                container.addEventListener('mouseenter', () => {
                    if (state.chartTool.activeAzimuth === az && state.chartTool.mode !== 'none') {
                        if (crosshair) crosshair.classList.add('visible');
                        if (coordinates) coordinates.classList.add('visible');
                    }
                });
                
                // Mouse leave - hide interactive elements
                container.addEventListener('mouseleave', () => {
                    if (crosshair) crosshair.classList.remove('visible');
                    if (previewPoint) previewPoint.classList.remove('visible');
                    if (previewSegment) previewSegment.classList.remove('visible');
                    if (coordinates) coordinates.classList.remove('visible');
                });
                
                // Mouse move - update overlays and coordinates
                container.addEventListener('mousemove', (e) => {
                    if (state.chartTool.activeAzimuth !== az || state.chartTool.mode === 'none') return;
                    
                    const chart = chartInstances[az];
                    if (!chart) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Update crosshair position
                    if (crosshair) {
                        const verticalLine = crosshair.querySelector('.chart-crosshair-vertical');
                        const horizontalLine = crosshair.querySelector('.chart-crosshair-horizontal');
                        if (verticalLine) verticalLine.style.left = x + 'px';
                        if (horizontalLine) horizontalLine.style.top = y + 'px';
                    }
                    
                    // Get chart coordinates
                    const xVal = chart.scales.x.getValueForPixel(x);
                    const yVal = interpolateY(chart, xVal);
                    
                    // Update coordinate display
                    if (coordinates && yVal !== null) {
                        const xCoord = coordinates.querySelector('.coord-x span');
                        const yCoord = coordinates.querySelector('.coord-y span');
                        const distUnit = state.units.profileDistance;
                        const elevUnit = state.units.profileElevation;
                        
                        if (xCoord) xCoord.textContent = `${xVal.toFixed(1)} ${distUnit}`;
                        if (yCoord) yCoord.textContent = `${yVal.toFixed(1)} ${elevUnit}`;
                    }
                    
                    // Handle tool-specific previews
                    if (state.chartTool.mode === 'point' && yVal !== null) {
                        updatePointPreview(previewPoint, x, y);
                    } else if (state.chartTool.mode === 'segment') {
                        updateSegmentPreview(previewSegment, chart, x, y, xVal);
                    }
                });
            });
        }
        
        function updatePointPreview(previewPoint, x, y) {
            if (!previewPoint) return;
            
            previewPoint.style.left = x + 'px';
            previewPoint.style.top = y + 'px';
            previewPoint.classList.add('visible', 'pulse');
        }
        
        function updateSegmentPreview(previewSegment, chart, x, y, xVal) {
            if (!previewSegment) return;
            
            if (state.chartTool.pending === null) {
                // No pending segment, just show point preview
                previewSegment.classList.remove('visible');
            } else {
                // Show segment preview from pending point to current position
                const pendingXFt = state.chartTool.pending;
                const pendingXVal = ftToUnitX(pendingXFt);
                const currentXVal = xVal;
                
                const pendingPx = chart.scales.x.getPixelForValue(pendingXVal);
                const currentPx = x;
                
                const left = Math.min(pendingPx, currentPx);
                const width = Math.abs(currentPx - pendingPx);
                
                // Position the segment preview
                previewSegment.style.left = left + 'px';
                previewSegment.style.top = (y - 1.5) + 'px'; // Center on cursor
                previewSegment.style.width = width + 'px';
                previewSegment.classList.add('visible');
            }
        }

        function handleChartClick(chart, evt) {
            // Only handle clicks if a tool is active and matches this chart's azimuth
            const az = chart.$azimuth;
            if (state.chartTool.activeAzimuth !== az || state.chartTool.mode === 'none') return;
            
            const { top, left } = chart.canvas.getBoundingClientRect();
            const px = evt.clientX - left;
            const py = evt.clientY - top;
            const xVal = chart.scales.x.getValueForPixel(px);
            const yVal = interpolateY(chart, xVal);
            if (yVal == null) return;

            const anno = ensureAzAnnotations(az);
            
            if (state.chartTool.mode === 'point') {
                // Add point with animation feedback
                const id = annotationIdCounter++;
                const type = state.chartTool.pointType;
                const label = type.replace('-', ' ');
                anno.points.push({ id, type, xFt: unitXToFt(xVal), yFt: unitYToFt(yVal), label });
                
                // Add visual feedback
                showPointAddedFeedback(az, px, py);
                
                chart.update();
                
            } else if (state.chartTool.mode === 'segment') {
                if (state.chartTool.pending == null) {
                    // Start new segment
                    state.chartTool.pending = unitXToFt(xVal);
                    
                    // Update UI to show pending state
                    updateAllToolButtons();
                    updateToolStatus();
                    
                    // Add visual feedback for segment start
                    showSegmentStartFeedback(az, px, py);
                    
                } else {
                    // Complete segment
                    const x1Ft = state.chartTool.pending;
                    const x2Ft = unitXToFt(xVal);
                    const id = annotationIdCounter++;
                    const segClass = state.chartTool.segmentClass;
                    const label = segClass;
                    
                    anno.segments.push({ id, class: segClass, x1Ft, x2Ft, label });
                    state.chartTool.pending = null;
                    
                    // Update UI to clear pending state
                    updateAllToolButtons();
                    updateToolStatus();
                    updateChartContainerStates();
                    
                    // Add visual feedback for segment completion
                    showSegmentCompletedFeedback(az);
                    
                    chart.update();
                }
            }
        }
        
        function showPointAddedFeedback(az, x, y) {
            const container = document.querySelector(`#chart-canvas-${az}`)?.closest('.chart-container');
            if (!container) return;
            
            // Create temporary feedback element
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                border: 3px solid rgba(255, 255, 255, 0.9);
                transform: translate(-50%, -50%) scale(0);
                pointer-events: none;
                z-index: 25;
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
                animation: pointAddedPulse 0.6s ease-out forwards;
            `;
            
            container.appendChild(feedback);
            
            // Remove after animation
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.parentNode.removeChild(feedback);
                }
            }, 600);
        }
        
        function showSegmentStartFeedback(az, x, y) {
            const container = document.querySelector(`#chart-canvas-${az}`)?.closest('.chart-container');
            if (!container) return;
            
            // Create start point marker
            const startMarker = document.createElement('div');
            startMarker.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: #f59e0b;
                border: 2px solid rgba(255, 255, 255, 0.9);
                transform: translate(-50%, -50%) scale(0);
                pointer-events: none;
                z-index: 25;
                animation: segmentStartPulse 0.4s ease-out forwards;
            `;
            
            startMarker.className = 'segment-start-marker';
            container.appendChild(startMarker);
            
            // Keep marker visible until segment is completed
        }
        
        function showSegmentCompletedFeedback(az) {
            const container = document.querySelector(`#chart-canvas-${az}`)?.closest('.chart-container');
            if (!container) return;
            
            // Remove start marker
            const startMarker = container.querySelector('.segment-start-marker');
            if (startMarker) {
                startMarker.style.animation = 'segmentCompleteOut 0.3s ease-out forwards';
                setTimeout(() => {
                    if (startMarker.parentNode) {
                        startMarker.parentNode.removeChild(startMarker);
                    }
                }, 300);
            }
            
            // Show completion flash
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(16, 185, 129, 0.1);
                border-radius: 8px;
                pointer-events: none;
                z-index: 5;
                animation: segmentCompleteFlash 0.5s ease-out forwards;
            `;
            
            container.appendChild(flash);
            
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 500);
        }

        // =========================================================================
        // FLOATING CHART TOOLS PALETTE SYSTEM
        // =========================================================================
        
        // Floating palette state management
        const floatingToolsState = {
            isVisible: false,
            isMinimized: false,
            isDragging: false,
            targetAzimuth: null,
            position: { x: 30, y: 80 }, // right offset, top offset
            dragOffset: { x: 0, y: 0 },
            doubleClickTimer: null,
            singleRightClickTimer: null,
            lastClickTime: 0
        };

        // Initialize floating tool palette
        function initializeFloatingToolPalette() {
            const palette = document.getElementById('floating-tools-palette');
            if (!palette) return;

            // Set initial position from state
            updatePalettePosition();
            
            // Update UI based on current tool state
            updateFloatingToolUI();
            
            // Setup event listeners
            setupFloatingToolEventListeners();
            
            // Setup drag functionality
            setupPaletteDragging();
            
            // Setup keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Setup auto-hide
            setupAutoHide();
            
            // Setup double-click detection on all charts
            setupChartDoubleClickDetection();
            
            console.log('Floating Tool Palette initialized with enhanced features');
        }

        // Update palette position
        function updatePalettePosition() {
            const palette = document.getElementById('floating-tools-palette');
            if (!palette) return;
            
            // Position from right edge and top
            palette.style.right = floatingToolsState.position.x + 'px';
            palette.style.top = floatingToolsState.position.y + 'px';
        }

        // Show floating tool palette with animation
        function showFloatingToolPalette() {
            const palette = document.getElementById('floating-tools-palette');
            if (!palette || floatingToolsState.isVisible) return;
            
            floatingToolsState.isVisible = true;
            palette.classList.remove('hidden');
            palette.classList.add('entering');
            
            // Update tool state display
            updateFloatingToolUI();
            
            setTimeout(() => {
                palette.classList.remove('entering');
            }, 400);
            
            console.log('Floating Tool Palette shown');
        }

        // Hide floating tool palette with animation
        function hideFloatingToolPalette() {
            const palette = document.getElementById('floating-tools-palette');
            if (!palette || !floatingToolsState.isVisible) return;
            
            palette.classList.add('leaving');
            
            setTimeout(() => {
                floatingToolsState.isVisible = false;
                palette.classList.add('hidden');
                palette.classList.remove('leaving');
            }, 300);
            
            console.log('Floating Tool Palette hidden');
        }

        // Toggle floating tool palette visibility
        function toggleFloatingToolPalette() {
            if (floatingToolsState.isVisible) {
                hideFloatingToolPalette();
            } else {
                showFloatingToolPalette();
            }
        }

        // Minimize/restore palette
        function minimizeFloatingToolPalette() {
            const palette = document.getElementById('floating-tools-palette');
            if (!palette) return;
            
            floatingToolsState.isMinimized = true;
            palette.classList.add('minimized');
            
            // Click to restore when minimized
            palette.onclick = restoreFloatingToolPalette;
        }

        function restoreFloatingToolPalette() {
            const palette = document.getElementById('floating-tools-palette');
            if (!palette) return;
            
            floatingToolsState.isMinimized = false;
            palette.classList.remove('minimized');
            palette.onclick = null;
        }

        // Setup event listeners for floating tool palette
        function setupFloatingToolEventListeners() {
            // Header controls
            const minimizeBtn = document.querySelector('.palette-minimize');
            const closeBtn = document.querySelector('.palette-close');
            
            if (minimizeBtn) {
                minimizeBtn.onclick = (e) => {
                    e.stopPropagation();
                    minimizeFloatingToolPalette();
                };
            }
            
            if (closeBtn) {
                closeBtn.onclick = (e) => {
                    e.stopPropagation();
                    hideFloatingToolPalette();
                };
            }

            // Tool mode buttons
            document.querySelectorAll('.tool-mode-btn').forEach(btn => {
                btn.onclick = () => {
                    const mode = btn.dataset.mode;
                    setFloatingToolMode(mode);
                };
            });

            // Point type selection
            document.querySelectorAll('[data-point-type]').forEach(btn => {
                btn.onclick = () => {
                    const pointType = btn.dataset.pointType;
                    setFloatingPointType(pointType);
                };
            });

            // Segment class selection
            document.querySelectorAll('[data-segment-class]').forEach(btn => {
                btn.onclick = () => {
                    const segmentClass = btn.dataset.segmentClass;
                    setFloatingSegmentClass(segmentClass);
                };
            });

            // Global tools
            const annotationToggle = document.querySelector('.annotation-visibility-toggle');
            const clearAllBtn = document.querySelector('.clear-all-annotations');
            
            if (annotationToggle) {
                annotationToggle.onclick = () => toggleGlobalAnnotationVisibility();
            }
            
            if (clearAllBtn) {
                clearAllBtn.onclick = () => clearAllAnnotationsGlobal();
            }
        }

        // Set tool mode from floating palette
        function setFloatingToolMode(mode) {
            // Update global state
            state.chartTool.mode = mode;
            
            // Update floating palette UI
            updateFloatingToolUI();
            updateToolSectionVisibility();
            
            // Update all chart tools
            updateAllToolButtons();
            updateChartContainerStates();
            
            console.log(`Tool mode set to: ${mode}`);
        }

        // Set point type from floating palette
        function setFloatingPointType(pointType) {
            state.chartTool.pointType = pointType;
            updateFloatingToolUI();
            console.log(`Point type set to: ${pointType}`);
        }

        // Set segment class from floating palette
        function setFloatingSegmentClass(segmentClass) {
            state.chartTool.segmentClass = segmentClass;
            updateFloatingToolUI();
            console.log(`Segment class set to: ${segmentClass}`);
        }

        // Update tool section visibility based on mode
        function updateToolSectionVisibility() {
            const pointSection = document.querySelector('.tool-section.point-tools');
            const segmentSection = document.querySelector('.tool-section.segment-tools');
            
            if (pointSection) {
                if (state.chartTool.mode === 'point') {
                    pointSection.classList.remove('hidden');
                } else {
                    pointSection.classList.add('hidden');
                }
            }
            
            if (segmentSection) {
                if (state.chartTool.mode === 'segment') {
                    segmentSection.classList.remove('hidden');
                } else {
                    segmentSection.classList.add('hidden');
                }
            }
        }

        // Update floating tool palette UI to reflect current state
        function updateFloatingToolUI() {
            // Update mode buttons
            document.querySelectorAll('.tool-mode-btn').forEach(btn => {
                const mode = btn.dataset.mode;
                if (mode === state.chartTool.mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update point type buttons
            document.querySelectorAll('[data-point-type]').forEach(btn => {
                const pointType = btn.dataset.pointType;
                if (pointType === state.chartTool.pointType) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update segment class buttons
            document.querySelectorAll('[data-segment-class]').forEach(btn => {
                const segmentClass = btn.dataset.segmentClass;
                if (segmentClass === state.chartTool.segmentClass) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update target chart display
            updateTargetChartDisplay();
            
            // Update annotation visibility toggle
            updateAnnotationVisibilityToggle();
        }

        // Update target chart display
        function updateTargetChartDisplay() {
            const chartAzimuth = document.querySelector('.chart-azimuth');
            const chartHighlight = document.querySelector('.chart-highlight-indicator');
            
            if (chartAzimuth && chartHighlight) {
                if (floatingToolsState.targetAzimuth !== null) {
                    chartAzimuth.textContent = `Azimuth ${floatingToolsState.targetAzimuth}°`;
                    chartHighlight.classList.add('active');
                } else {
                    chartAzimuth.textContent = 'No chart selected';
                    chartHighlight.classList.remove('active');
                }
            }
        }

        // Update annotation visibility toggle state
        function updateAnnotationVisibilityToggle() {
            const toggle = document.querySelector('.annotation-visibility-toggle');
            if (!toggle) return;
            
            // Check if any annotations are visible
            let anyVisible = false;
            Object.values(state.annotationsByAzimuth).forEach(azData => {
                if (azData.visible) anyVisible = true;
            });
            
            if (anyVisible) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
        }

        // Toggle global annotation visibility
        function toggleGlobalAnnotationVisibility() {
            // Check current state
            let anyVisible = false;
            Object.values(state.annotationsByAzimuth).forEach(azData => {
                if (azData.visible) anyVisible = true;
            });
            
            // Toggle all
            const newState = !anyVisible;
            Object.keys(state.annotationsByAzimuth).forEach(az => {
                state.annotationsByAzimuth[az].visible = newState;
            });
            
            // Update all charts
            renderCharts();
            updateFloatingToolUI();
            
            console.log(`Global annotation visibility: ${newState}`);
        }

        // Clear all annotations globally
        function clearAllAnnotationsGlobal() {
            if (!confirm('Clear all annotations from all charts?')) return;
            
            Object.keys(state.annotationsByAzimuth).forEach(az => {
                const azData = state.annotationsByAzimuth[az];
                azData.points = [];
                azData.segments = [];
            });
            
            // Reset any pending segment operations
            state.chartTool.pending = null;
            
            // Update all charts and UI
            renderCharts();
            updateFloatingToolUI();
            
            console.log('All annotations cleared');
        }

        // Setup dragging functionality
        function setupPaletteDragging() {
            const dragHandle = document.querySelector('.palette-drag-handle');
            const palette = document.getElementById('floating-tools-palette');
            
            if (!dragHandle || !palette) return;
            
            let isDragging = false;
            
            dragHandle.onmousedown = (e) => {
                isDragging = true;
                floatingToolsState.isDragging = true;
                
                const rect = palette.getBoundingClientRect();
                floatingToolsState.dragOffset.x = e.clientX - rect.left;
                floatingToolsState.dragOffset.y = e.clientY - rect.top;
                
                document.body.style.userSelect = 'none';
                palette.style.transition = 'none';
                
                e.preventDefault();
            };
            
            document.onmousemove = (e) => {
                if (!isDragging) return;
                
                const x = window.innerWidth - (e.clientX - floatingToolsState.dragOffset.x) - palette.offsetWidth;
                const y = e.clientY - floatingToolsState.dragOffset.y;
                
                // Constrain to viewport
                const constrainedX = Math.max(10, Math.min(x, window.innerWidth - palette.offsetWidth - 10));
                const constrainedY = Math.max(10, Math.min(y, window.innerHeight - palette.offsetHeight - 10));
                
                floatingToolsState.position.x = constrainedX;
                floatingToolsState.position.y = constrainedY;
                
                updatePalettePosition();
            };
            
            document.onmouseup = () => {
                if (isDragging) {
                    isDragging = false;
                    floatingToolsState.isDragging = false;
                    document.body.style.userSelect = '';
                    palette.style.transition = '';
                }
            };
        }

        // Setup double-click detection on charts
        function setupChartDoubleClickDetection() {
            // We'll enhance the existing chart mouse handlers
            console.log('Setting up chart double-click detection');
        }

        // Enhanced chart click handler for floating tools
        function handleFloatingChartInteraction(chart, evt, azimuth) {
            const currentTime = Date.now();
            const timeDiff = currentTime - floatingToolsState.lastClickTime;
            // Normalize right-click detection for both mousedown/click and contextmenu events
            const isRightClick = evt.button === 2 || evt.type === 'contextmenu';

            // Handle double right-click detection
            if (isRightClick) {
                if (timeDiff < 500 && floatingToolsState.doubleClickTimer) {
                    // Double right-click detected
                    clearTimeout(floatingToolsState.doubleClickTimer);
                    if (floatingToolsState.singleRightClickTimer) {
                        clearTimeout(floatingToolsState.singleRightClickTimer);
                        floatingToolsState.singleRightClickTimer = null;
                    }
                    floatingToolsState.doubleClickTimer = null;
                    toggleFloatingToolPalette();
                    evt.preventDefault();
                    return;
                } else {
                    // First right-click: start double-click window and schedule single-click handling
                    if (floatingToolsState.doubleClickTimer) {
                        clearTimeout(floatingToolsState.doubleClickTimer);
                    }
                    floatingToolsState.doubleClickTimer = setTimeout(() => {
                        floatingToolsState.doubleClickTimer = null;
                    }, 500);

                    // Clear any pending single-right-click action and schedule a new one
                    if (floatingToolsState.singleRightClickTimer) {
                        clearTimeout(floatingToolsState.singleRightClickTimer);
                        floatingToolsState.singleRightClickTimer = null;
                    }

                    floatingToolsState.singleRightClickTimer = setTimeout(() => {
                        // If a double-click occurred, this timer would have been cleared
                        const { chartArea, scales } = chart;
                        if (!chartArea || !scales?.x || !scales?.y) return;

                        // Compute canvas-relative coordinates
                        const rect = chart.canvas.getBoundingClientRect();
                        const x = (typeof evt.offsetX === 'number') ? evt.offsetX : (evt.clientX - rect.left);
                        const y = (typeof evt.offsetY === 'number') ? evt.offsetY : (evt.clientY - rect.top);

                        const anno = ensureAzAnnotations(azimuth);
                        const hit = findAnnotationAtPosition(anno, x, y, chartArea, scales.x, scales.y);
                        if (hit) {
                            showFloatingAnnotationEditor(hit.annotation, azimuth, hit.type);
                        }
                    }, 520);
                }
            }
            
            // Handle chart targeting (left click)
            if (evt.button === 0) { // Left click
                // Set target chart
                floatingToolsState.targetAzimuth = azimuth;
                state.chartTool.activeAzimuth = azimuth;
                updateTargetChartDisplay();
                
                // Add visual feedback to targeted chart
                highlightTargetChart(azimuth);
                
                // If floating palette is visible and tool is active, handle annotation
                if (floatingToolsState.isVisible && state.chartTool.mode !== 'none') {
                    handleChartClick(chart, evt);
                }
            }
            
            floatingToolsState.lastClickTime = currentTime;
        }

        // Add visual highlight to targeted chart
        function highlightTargetChart(azimuth) {
            // Remove previous highlights
            document.querySelectorAll('.chart-container').forEach(container => {
                container.classList.remove('chart-targeted');
            });
            
            // Add highlight to current target
            const targetContainer = document.querySelector(`[data-azimuth="${azimuth}"] .chart-container`);
            if (targetContainer) {
                targetContainer.classList.add('chart-targeted');
                
                // Remove highlight after a delay
                setTimeout(() => {
                    targetContainer.classList.remove('chart-targeted');
                }, 2000);
            }
        }

        // Keyboard shortcuts for floating tool palette
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts when no input is focused
                if (document.activeElement.tagName === 'INPUT' || 
                    document.activeElement.tagName === 'SELECT' ||
                    document.activeElement.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Ctrl/Cmd + T: Toggle floating tool palette
                if ((e.ctrlKey || e.metaKey) && e.key === 't') {
                    e.preventDefault();
                    toggleFloatingToolPalette();
                    return;
                }
                
                // Only handle tool shortcuts when palette is visible
                if (!floatingToolsState.isVisible) return;
                
                switch(e.key) {
                    case '1':
                        e.preventDefault();
                        setFloatingToolMode('none');
                        break;
                    case '2':
                        e.preventDefault();
                        setFloatingToolMode('point');
                        break;
                    case '3':
                        e.preventDefault();
                        setFloatingToolMode('segment');
                        break;
                    case 'Escape':
                        e.preventDefault();
                        setFloatingToolMode('none');
                        break;
                    case 'v':
                        e.preventDefault();
                        toggleGlobalAnnotationVisibility();
                        break;
                    case 'c':
                        e.preventDefault();
                        if (e.shiftKey) {
                            clearAllAnnotationsGlobal();
                        }
                        break;
                }
            });
        }

        // Auto-hide functionality
        function setupAutoHide() {
            let autoHideTimer;
            const palette = document.getElementById('floating-tools-palette');
            
            function resetAutoHideTimer() {
                clearTimeout(autoHideTimer);
                autoHideTimer = setTimeout(() => {
                    if (floatingToolsState.isVisible && !floatingToolsState.isDragging) {
                        // Only auto-hide if no tool is active
                        if (state.chartTool.mode === 'none') {
                            hideFloatingToolPalette();
                        }
                    }
                }, 30000); // 30 seconds of inactivity
            }
            
            // Reset timer on any interaction
            if (palette) {
                palette.addEventListener('mouseenter', () => clearTimeout(autoHideTimer));
                palette.addEventListener('mouseleave', resetAutoHideTimer);
                palette.addEventListener('click', resetAutoHideTimer);
            }
            
            // Reset timer on chart interactions
            document.addEventListener('click', (e) => {
                if (e.target.closest('.chart-container')) {
                    resetAutoHideTimer();
                }
            });
        }

        
        function renderCharts() {
            for (const chart of Object.values(chartInstances)) { chart.destroy(); }
            chartInstances = {};
            if (!pluginRegistered && Chart && Chart.registry) {
                Chart.register(enhancedKztAnnotationsPlugin);
                pluginRegistered = true;
            }

            const visibleAzimuths = sampleResults.filter(r => r.status === 'success' && !r.isCollapsed);

            for (const result of visibleAzimuths) {
                const canvas = document.getElementById(`chart-canvas-${result.windDirection}`);
                if (!canvas) continue;

                // Check if the graph section is expanded (visible)
                const graphSection = canvas.closest('.collapsible-content');
                if (graphSection && graphSection.classList.contains('is-collapsed')) {
                    continue; // Skip rendering for collapsed sections
                }

                const distanceUnit = state.units.profileDistance;
                const elevationUnit = state.units.profileElevation;
                const azColor = getAzimuthColor(result.windDirection);

                // Get profile data based on current view setting
                let profileData = result.profileData;
                if (state.profileView === 'diametral') {
                    profileData = generateDiametralProfileData(result.windDirection, result.siteInfo.crestElev);
                }

                const chartData = profileData.map(p => ({
                    x: convertFromFt(p.distance, distanceUnit),
                    y: convertFromFt(p.elevation, elevationUnit)
                }));

                const ctx = canvas.getContext('2d');

                // Get display mode for this azimuth
                const displayMode = state.chartDisplayModes?.[result.windDirection] || 'filled';
                const isLineMode = displayMode === 'line';

                let datasets;
                if (state.profileView === 'diametral') {
                    // Split data into current and opposite azimuth datasets
                    const currentData = chartData.filter(p => p.x >= 0);
                    const oppositeData = chartData.filter(p => p.x <= 0);
                    const oppositeAzimuth = (result.windDirection + 180) % 360;
                    const oppositeColor = getAzimuthColor(oppositeAzimuth);

                    datasets = [
                        {
                            label: `Azimuth ${oppositeAzimuth}°`,
                            data: oppositeData,
                            borderColor: oppositeColor.line,
                            backgroundColor: isLineMode ? 'transparent' : colorWithAlpha(oppositeColor.line, 0.1),
                            fill: !isLineMode,
                            tension: 0.1,
                            pointRadius: isLineMode ? 3 : 2,
                            borderWidth: isLineMode ? 3 : 2,
                        },
                        {
                            label: `Azimuth ${result.windDirection}°`,
                            data: currentData,
                            borderColor: azColor.line,
                            backgroundColor: isLineMode ? 'transparent' : colorWithAlpha(azColor.line, 0.1),
                            fill: !isLineMode,
                            tension: 0.1,
                            pointRadius: isLineMode ? 3 : 2,
                            borderWidth: isLineMode ? 3 : 2,
                        }
                    ];
                } else {
                    datasets = [{
                        label: `Azimuth ${result.windDirection}°`,
                        data: chartData,
                        borderColor: azColor.line,
                        backgroundColor: isLineMode ? 'transparent' : colorWithAlpha(azColor.line, 0.1),
                        fill: !isLineMode,
                        tension: 0.1,
                        pointRadius: isLineMode ? 3 : 2,
                        borderWidth: isLineMode ? 3 : 2,
                    }];
                }

                const newChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: `Distance (${distanceUnit})` },
                                min: state.profileView === 'radial' ? 0 : undefined,
                                max: state.profileView === 'radial' ? undefined : undefined,
                                grid: {
                                    color: function (context) {
                                        if (context.tick.value === 0 && state.profileView === 'diametral') {
                                            return 'rgba(0, 0, 0, 0.3)';
                                        }
                                        return 'rgba(0, 0, 0, 0.1)';
                                    },
                                    lineWidth: function (context) {
                                        if (context.tick.value === 0 && state.profileView === 'diametral') {
                                            return 2;
                                        }
                                        return 1;
                                    }
                                }
                            },
                            y: {
                                title: { display: true, text: `Elevation (${elevationUnit})` }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false  // Disable built-in legend, use custom centered legend only
                            }
                        },
                        animation: {
                            onComplete: function (animation) {
                                const chart = animation.chart;
                                const ctx = chart.ctx;
                                const scale = chart.scales.x;
                                const chartArea = chart.chartArea;

                                // Determine azimuths and colors
                                const oppositeAzimuth = (result.windDirection + 180) % 360;
                                const currentColor = getAzimuthColor(result.windDirection).line;
                                const oppositeColor = getAzimuthColor(oppositeAzimuth).line;

                                ctx.save();
                                ctx.font = 'bold 14px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'top';

                                const swatchSize = 12;
                                const paddingTop = 12;

                                // Helper to draw centered label + swatch on a side area
                                function drawSide(centerX, label, color) {
                                    const swX = centerX - swatchSize - 6;
                                    const swY = chartArea.top + paddingTop;
                                    // draw swatch
                                    ctx.fillStyle = color;
                                    ctx.fillRect(swX, swY, swatchSize, swatchSize);
                                    // draw label to the right of swatch
                                    ctx.fillStyle = color;
                                    ctx.fillText(label, centerX + (swatchSize / 2) - 2, swY);
                                }

                                if (state.profileView === 'diametral') {
                                    // Left center: between left edge and x=0 pixel
                                    if (scale.min < 0) {
                                        const zeroPx = scale.getPixelForValue(0);
                                        const leftCenter = chartArea.left + (zeroPx - chartArea.left) / 2;
                                        drawSide(leftCenter, `${oppositeAzimuth}°`, oppositeColor);
                                    }
                                    // Right center: between x=0 pixel and right edge
                                    if (scale.max > 0) {
                                        const zeroPx = scale.getPixelForValue(0);
                                        const rightCenter = zeroPx + (chartArea.right - zeroPx) / 2;
                                        drawSide(rightCenter, `${result.windDirection}°`, currentColor);
                                    }
                                } else {
                                    // Radial view: only show the current azimuth label on the right side area (centered vertically near top)
                                    const rightCenter = chartArea.left + (chartArea.right - chartArea.left) * 0.66; // biased to right
                                    drawSide(rightCenter, `${result.windDirection}°`, currentColor);
                                }

                                ctx.restore();
                            }
                        }
                    }
                });

                newChart.$azimuth = result.windDirection;
                chartInstances[result.windDirection] = newChart;
            }

            // Attach enhanced click handlers for floating tool palette integration
            Object.values(chartInstances).forEach(chart => {
                if (!chart) return;
                const canvas = chart.canvas;
                
                // Get azimuth from chart configuration
                const azimuth = chart.options.plugins?.kztAnnotations?.azimuth || 
                               chart.config?.azimuth || 
                               parseInt(canvas.closest('.kzt-card')?.dataset.azimuth);
                
                // Enhanced click handler with floating tools support
                canvas.onclick = (evt) => {
                    handleFloatingChartInteraction(chart, evt, azimuth);
                };
                
                // Add context menu handler for right-click detection
                canvas.oncontextmenu = (evt) => {
                    evt.preventDefault(); // Prevent context menu
                    handleFloatingChartInteraction(chart, evt, azimuth);
                };
                
                // Store azimuth reference on chart for easy access
                chart.azimuth = azimuth;
            });

            // Set up enhanced mouse handlers for all charts
            setTimeout(() => setupChartMouseHandlers(), 50);
        }

        // Enhanced Expandable Panel System
        function setupExpandablePanels() {
            // Initialize panel states
            if (!state.viewPanels) {
                state.viewPanels = {};
            }

            document.querySelectorAll('.panel-expand-btn').forEach(btn => {
                const azimuth = parseInt(btn.dataset.az, 10);
                
                // Initialize expanded state from storage or default to false
                const isExpanded = state.viewPanels[azimuth] || false;
                updatePanelState(azimuth, isExpanded);
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const currentExpanded = state.viewPanels[azimuth] || false;
                    const newExpanded = !currentExpanded;
                    
                    // Update state and save to storage
                    saveViewPanelState(azimuth, newExpanded);
                    
                    // Animate the panel
                    animatePanelTransition(azimuth, newExpanded);
                    
                    // Update button state
                    updateExpandButtonState(btn, newExpanded);
                });
            });
        }

        function updatePanelState(azimuth, expanded) {
            const container = document.querySelector(`[data-az="${azimuth}"].view-panel-container`);
            const expandableSection = container?.querySelector('.view-panel-expandable');
            const expandBtn = container?.querySelector('.panel-expand-btn');
            
            if (expandableSection) {
                if (expanded) {
                    expandableSection.classList.add('expanded');
                } else {
                    expandableSection.classList.remove('expanded');
                }
            }
            
            if (expandBtn) {
                updateExpandButtonState(expandBtn, expanded);
            }
        }

        function updateExpandButtonState(btn, expanded) {
            if (expanded) {
                btn.classList.add('expanded');
                btn.title = 'Collapse view options';
            } else {
                btn.classList.remove('expanded');
                btn.title = 'Expand view options';
            }
        }

        function animatePanelTransition(azimuth, expanding) {
            const container = document.querySelector(`[data-az="${azimuth}"].view-panel-container`);
            const expandableSection = container?.querySelector('.view-panel-expandable');
            
            if (!expandableSection) return;
            
            // Add transitioning class for additional styling control
            expandableSection.classList.add('transitioning');
            
            // Use requestAnimationFrame for smooth animation
            requestAnimationFrame(() => {
                if (expanding) {
                    // compute a suitable width based on content but clamp to viewport width
                    const computedWidth = computeExpandableWidth(expandableSection);
                    expandableSection.style.width = computedWidth + 'px';
                    expandableSection.classList.add('expanded');
                } else {
                    // collapsing: clear inline width to allow CSS to handle
                    expandableSection.classList.remove('expanded');
                    expandableSection.style.width = '';
                }
                
                // Remove transitioning class after animation completes
                setTimeout(() => {
                    expandableSection.classList.remove('transitioning');
                }, 400); // Match CSS transition duration
            });
        }

        // Compute an adaptive width for the expandable tools section so it fits content and viewport
        function computeExpandableWidth(expandableSection) {
            // measure children total width
            const children = Array.from(expandableSection.children);
            let total = 0;
            children.forEach(ch => {
                const style = window.getComputedStyle(ch);
                const w = ch.offsetWidth + parseFloat(style.marginLeft || 0) + parseFloat(style.marginRight || 0);
                total += w;
            });
            // Add some padding buffer
            const buffer = 24;
            const desired = Math.min(total + buffer, Math.floor(window.innerWidth * 0.8));
            // ensure a sensible minimum
            return Math.max(desired, 320);
        }

        // Recompute widths on resize for open panels
        window.addEventListener('resize', () => {
            document.querySelectorAll('.view-panel-expandable.expanded').forEach(sec => {
                const w = computeExpandableWidth(sec);
                sec.style.width = w + 'px';
            });
        });

        // Chart Display Mode System
        function setupChartDisplayModes() {
            // Initialize display mode state
            if (!state.chartDisplayModes) {
                state.chartDisplayModes = {};
            }

            document.querySelectorAll('.display-mode-btn').forEach(btn => {
                const azimuth = parseInt(btn.dataset.az, 10);
                const mode = btn.dataset.mode;
                
                // Initialize mode from storage or default to 'filled'
                if (!state.chartDisplayModes[azimuth]) {
                    state.chartDisplayModes[azimuth] = 'filled';
                }
                
                // Set initial button states
                updateDisplayModeButtons(azimuth);
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const azimuth = parseInt(e.target.dataset.az, 10);
                    const mode = e.target.dataset.mode;
                    
                    // Update state and save to storage
                    saveChartDisplayMode(azimuth, mode);
                    
                    // Update button states
                    updateDisplayModeButtons(azimuth);
                    
                    // Re-render the specific chart with new display mode
                    updateChartDisplayMode(azimuth, mode);
                });
            });
        }

        function updateDisplayModeButtons(azimuth) {
            const currentMode = state.chartDisplayModes[azimuth] || 'filled';
            
            document.querySelectorAll(`[data-az="${azimuth}"].display-mode-btn`).forEach(btn => {
                const btnMode = btn.dataset.mode;
                if (btnMode === currentMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function updateChartDisplayMode(azimuth, mode) {
            const chart = chartInstances[azimuth];
            if (!chart) return;
            
            // Update chart style based on display mode
            chart.data.datasets.forEach(dataset => {
                if (mode === 'line') {
                    // Line only mode
                    dataset.fill = false;
                    dataset.backgroundColor = 'transparent';
                    dataset.borderWidth = 3;
                    dataset.pointRadius = 3;
                    dataset.pointHoverRadius = 5;
                } else {
                    // Filled mode (default)
                    dataset.fill = true;
                    const baseColor = dataset.borderColor;
                    dataset.backgroundColor = colorWithAlpha(baseColor, 0.1);
                    dataset.borderWidth = 2;
                    dataset.pointRadius = 2;
                    dataset.pointHoverRadius = 4;
                }
            });
            
            // Animate the chart update
            chart.update();
        }

        // Enhanced State Persistence System
        function saveViewPanelState(azimuth, expanded) {
            state.viewPanels[azimuth] = expanded;
            localStorage.setItem('kzt-view-panels', JSON.stringify(state.viewPanels));
        }

        function loadViewPanelStates() {
            try {
                const saved = localStorage.getItem('kzt-view-panels');
                if (saved) {
                    state.viewPanels = { ...state.viewPanels, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.warn('Failed to load view panel states:', e);
            }
        }

        function saveChartDisplayMode(azimuth, mode) {
            state.chartDisplayModes[azimuth] = mode;
            localStorage.setItem('kzt-chart-display-modes', JSON.stringify(state.chartDisplayModes));
        }

        function loadChartDisplayModes() {
            try {
                const saved = localStorage.getItem('kzt-chart-display-modes');
                if (saved) {
                    state.chartDisplayModes = { ...state.chartDisplayModes, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.warn('Failed to load chart display modes:', e);
            }
        }

        function initializeViewStates() {
            // Load saved states from localStorage
            loadViewPanelStates();
            loadChartDisplayModes();
            
            // Apply default values for any missing azimuths
            if (sampleResults) {
                sampleResults.forEach(result => {
                    if (result.status === 'success') {
                        const az = result.windDirection;
                        if (state.viewPanels[az] === undefined) {
                            state.viewPanels[az] = false; // Default to collapsed
                        }
                        if (state.chartDisplayModes[az] === undefined) {
                            state.chartDisplayModes[az] = 'filled'; // Default to filled
                        }
                    }
                });
            }
        }

        // Integrated Chart Tools System
        function setupIntegratedChartTools() {
            setupSmartAnnotationToggle();
            setupPointDropdown();
            setupSegmentDropdown();
            setupClearButton();
            setupDropdownBehavior();
        }

        function setupSmartAnnotationToggle() {
            document.querySelectorAll('.anno-toggle-btn').forEach(btn => {
                const azimuth = parseInt(btn.dataset.az, 10);
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const anno = ensureAzAnnotations(azimuth);
                    anno.visible = !anno.visible;
                    
                    // Update button state and text
                    updateAnnotationToggleState(btn, anno.visible);
                    
                    // Update chart
                    if (chartInstances[azimuth]) {
                        chartInstances[azimuth].update();
                    }
                });
                
                // Initialize state
                const anno = ensureAzAnnotations(azimuth);
                updateAnnotationToggleState(btn, anno.visible);
            });
        }

        function updateAnnotationToggleState(btn, visible) {
            const textElement = btn.querySelector('.toggle-text');
            if (visible) {
                btn.classList.add('active');
                textElement.textContent = 'Annotations On';
            } else {
                btn.classList.remove('active');
                textElement.textContent = 'Annotations Off';
            }
        }

        function setupPointDropdown() {
            document.querySelectorAll('.point-dropdown').forEach(container => {
                const mainBtn = container.querySelector('.tool-point-main');
                const toggleBtn = container.querySelector('.dropdown-toggle');
                const azimuth = parseInt(mainBtn.dataset.az, 10);
                
                // Main button click - activate point tool
                mainBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const wasActive = state.chartTool.mode === 'point' && state.chartTool.activeAzimuth === azimuth;
                    
                    // Reset all tools first
                    resetAllToolStates();
                    
                    if (!wasActive) {
                        // Activate point tool for this azimuth
                        state.chartTool.mode = 'point';
                        state.chartTool.activeAzimuth = azimuth;
                        state.chartTool.pending = null;
                        
                        // Update UI states
                        updateToolVisualStates();
                        updateChartContainerStates();
                        showToolStatus(azimuth, 'point');
                    } else {
                        // Deactivate tool
                        state.chartTool.mode = 'none';
                        state.chartTool.activeAzimuth = null;
                        state.chartTool.pending = null;
                        hideAllToolStatuses();
                    }
                    
                    updateAllToolButtons();
                });
                
                // Dropdown item clicks - set point type
                container.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const pointType = e.target.dataset.type || e.target.closest('[data-type]').dataset.type;
                        state.chartTool.pointType = pointType;
                        
                        // Update active state in dropdown
                        container.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('active'));
                        const targetItem = e.target.closest('[data-type]');
                        if (targetItem) targetItem.classList.add('active');
                        
                        // Close dropdown and return focus to main button
                        closeDropdown(container);
                        const mainBtn = container.querySelector('.dropdown-btn');
                        if (mainBtn) mainBtn.focus();
                        
                        // Update status text if point tool is active
                        if (state.chartTool.mode === 'point') {
                            updateToolStatus();
                        }
                    });
                });
                
                // Initialize active item based on current state
                updatePointDropdownState(container);
                // If there's a toggle button, bind open/close to it and keep aria in sync
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleDropdown(container);
                        const expanded = container.classList.contains('open');
                        mainBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                    });
                    // Ensure clicking the main button clears other dropdowns but doesn't toggle menu
                    mainBtn.addEventListener('click', (e) => {
                        // existing logic will run from earlier binding; keep separation of concerns
                    });
                }
            });
        }

        function setupSegmentDropdown() {
            document.querySelectorAll('.segment-dropdown').forEach(container => {
                const mainBtn = container.querySelector('.tool-segment-main');
                const toggleBtn = container.querySelector('.dropdown-toggle');
                const azimuth = parseInt(mainBtn.dataset.az, 10);
                
                // Main button click - activate segment tool
                mainBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const wasActive = state.chartTool.mode === 'segment' && state.chartTool.activeAzimuth === azimuth;
                    
                    // Reset all tools first
                    resetAllToolStates();
                    
                    if (!wasActive) {
                        // Activate segment tool for this azimuth
                        state.chartTool.mode = 'segment';
                        state.chartTool.activeAzimuth = azimuth;
                        state.chartTool.pending = null;
                        
                        // Update UI states
                        updateToolVisualStates();
                        updateChartContainerStates();
                        showToolStatus(azimuth, 'segment');
                    } else {
                        // Deactivate tool
                        state.chartTool.mode = 'none';
                        state.chartTool.activeAzimuth = null;
                        state.chartTool.pending = null;
                        hideAllToolStatuses();
                    }
                    
                    updateAllToolButtons();
                });
                
                // Dropdown item clicks - set segment class
                container.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const segmentClass = e.target.dataset.class || e.target.closest('[data-class]').dataset.class;
                        state.chartTool.segmentClass = segmentClass;
                        
                        // Update active state in dropdown
                        container.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('active'));
                        const targetItem = e.target.closest('[data-class]');
                        if (targetItem) targetItem.classList.add('active');
                        
                        // Close dropdown and return focus to main button
                        closeDropdown(container);
                        const mainBtn = container.querySelector('.dropdown-btn');
                        if (mainBtn) mainBtn.focus();
                        
                        // Update status text if segment tool is active
                        if (state.chartTool.mode === 'segment') {
                            updateToolStatus();
                        }
                    });
                });
                
                // Initialize active item based on current state
                updateSegmentDropdownState(container);
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleDropdown(container);
                        const expanded = container.classList.contains('open');
                        mainBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                    });
                    mainBtn.addEventListener('click', (e) => {
                        // existing main button handler above will run; keep toggle separate
                    });
                }
            });
        }

        function setupClearButton() {
            document.querySelectorAll('.clear-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Use the button element's dataset to avoid issues when inner elements are clicked
                    const azimuth = parseInt(btn.dataset.az || btn.getAttribute('data-az'), 10);
                    const anno = ensureAzAnnotations(azimuth);
                    const hasAnnotations = (anno.points && anno.points.length > 0) || (anno.segments && anno.segments.length > 0);
                    
                    if (hasAnnotations) {
                        // Add confirmation for non-empty annotations
                        if (confirm('Clear all annotations for this azimuth?')) {
                            clearAnnotationsWithAnimation(azimuth);
                        }
                    } else {
                        clearAnnotationsWithAnimation(azimuth);
                    }
                });
            });
        }

        function setupDropdownBehavior() {
            // Close dropdowns when clicking outside or pressing Escape
            document.addEventListener('click', (e) => {
                // If the click happened inside a dropdown-container, allow specific handlers to manage it
                if (!e.target.closest('.dropdown-container')) {
                    closeAllDropdowns();
                }
            });

            // Keyboard accessibility: close on Escape and support opening with ArrowDown on focused toggle
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeAllDropdowns();
                    document.querySelectorAll('.dropdown-btn[aria-expanded="true"]').forEach(b => b.setAttribute('aria-expanded','false'));
                }
                // Open focused toggle with Enter or Space
                if ((e.key === 'Enter' || e.key === ' ') && document.activeElement && document.activeElement.classList.contains('dropdown-toggle')) {
                    e.preventDefault();
                    const container = document.activeElement.closest('.dropdown-container');
                    toggleDropdown(container);
                }
            });
        }

        function toggleDropdown(container) {
            const isOpen = container.classList.contains('open');
            
            // Close all other dropdowns first
            closeAllDropdowns();
            
            if (!isOpen) {
                container.classList.add('open');
                // move focus into the menu for accessibility
                const firstItem = container.querySelector('.dropdown-menu .dropdown-item');
                if (firstItem) firstItem.focus();
            }
        }

        function closeDropdown(container) {
            container.classList.remove('open');
            const mainBtn = container.querySelector('.dropdown-btn');
            if (mainBtn) mainBtn.setAttribute('aria-expanded', 'false');
        }

        function closeAllDropdowns() {
            document.querySelectorAll('.dropdown-container.open').forEach(container => {
                container.classList.remove('open');
                const mainBtn = container.querySelector('.dropdown-btn');
                if (mainBtn) mainBtn.setAttribute('aria-expanded', 'false');
            });
        }

        function updatePointDropdownState(container) {
            const currentType = state.chartTool.pointType;
            container.querySelectorAll('.dropdown-item').forEach(item => {
                if (item.dataset.type === currentType) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function updateSegmentDropdownState(container) {
            const currentClass = state.chartTool.segmentClass;
            container.querySelectorAll('.dropdown-item').forEach(item => {
                if (item.dataset.class === currentClass) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function renderSingleChart(azimuth) {
            const result = sampleResults.find(r => r.windDirection == azimuth);
            if (!result || result.status !== 'success') return;

            const canvas = document.getElementById(`chart-canvas-${azimuth}`);
            if (!canvas) return;

            // Destroy existing chart if it exists
            if (chartInstances[azimuth]) {
                chartInstances[azimuth].destroy();
                delete chartInstances[azimuth];
            }

            const distanceUnit = state.units.profileDistance;
            const elevationUnit = state.units.profileElevation;
            const azColor = getAzimuthColor(azimuth);

            // Get profile data based on current view setting
            let profileData = result.profileData;
            if (state.profileView === 'diametral') {
                profileData = generateDiametralProfileData(azimuth, result.siteInfo.crestElev);
            }

            const chartData = profileData.map(p => ({
                x: convertFromFt(p.distance, distanceUnit),
                y: convertFromFt(p.elevation, elevationUnit)
            }));

            // Debug logging
            console.log(`Single Chart Azimuth ${azimuth} - View: ${state.profileView} - Profile Data:`, profileData.slice(0, 3));
            console.log(`Single Chart Azimuth ${azimuth} - Chart Data:`, chartData.slice(0, 3));
            console.log(`Distance unit: ${distanceUnit}, Elevation unit: ${elevationUnit}`);

            const ctx = canvas.getContext('2d');
            if (!pluginRegistered && Chart && Chart.registry) {
                Chart.register(enhancedKztAnnotationsPlugin);
                pluginRegistered = true;
            }
            
            // Get display mode for this azimuth
            const displayMode = state.chartDisplayModes?.[azimuth] || 'filled';
            const isLineMode = displayMode === 'line';
            
            let datasets;
            if (state.profileView === 'diametral') {
                // Split data into current and opposite azimuth datasets
                const currentData = chartData.filter(p => p.x >= 0);
                const oppositeData = chartData.filter(p => p.x <= 0);
                const oppositeAzimuth = (azimuth + 180) % 360;
                const oppositeColor = getAzimuthColor(oppositeAzimuth);
                
                datasets = [
                    {
                        label: `Azimuth ${oppositeAzimuth}°`,
                        data: oppositeData,
                        borderColor: oppositeColor.line,
                        backgroundColor: isLineMode ? 'transparent' : colorWithAlpha(oppositeColor.line, 0.1),
                        fill: !isLineMode, 
                        tension: 0.1, 
                        pointRadius: isLineMode ? 3 : 2, 
                        borderWidth: isLineMode ? 3 : 2,
                    },
                    {
                        label: `Azimuth ${azimuth}°`,
                        data: currentData,
                        borderColor: azColor.line,
                        backgroundColor: isLineMode ? 'transparent' : colorWithAlpha(azColor.line, 0.1),
                        fill: !isLineMode, 
                        tension: 0.1, 
                        pointRadius: isLineMode ? 3 : 2, 
                        borderWidth: isLineMode ? 3 : 2,
                    }
                ];
            } else {
                datasets = [{
                    label: `Azimuth ${azimuth}°`,
                    data: chartData,
                    borderColor: azColor.line,
                    backgroundColor: isLineMode ? 'transparent' : colorWithAlpha(azColor.line, 0.1),
                    fill: !isLineMode, 
                    tension: 0.1, 
                    pointRadius: isLineMode ? 3 : 2, 
                    borderWidth: isLineMode ? 3 : 2,
                }];
            }
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: { 
                            type: 'linear',
                            title: { display: true, text: `Distance (${distanceUnit})` },
                            min: state.profileView === 'radial' ? 0 : undefined,
                            grid: {
                                color: function(context) {
                                    if (context.tick.value === 0 && state.profileView === 'diametral') {
                                        return 'rgba(0, 0, 0, 0.3)';
                                    }
                                    return 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    if (context.tick.value === 0 && state.profileView === 'diametral') {
                                        return 2;
                                    }
                                    return 1;
                                }
                            }
                        },
                        y: { 
                            title: { display: true, text: `Elevation (${elevationUnit})` } 
                        }
                    },
                    plugins: { 
                        legend: { 
                            display: false  // Disable built-in legend, use custom centered legend only
                        } 
                    },
                    animation: {
                        onComplete: function(animation) {
                            if (state.profileView === 'diametral') {
                                const chart = animation.chart;
                                const ctx = chart.ctx;
                                const scale = chart.scales.x;
                                const chartArea = chart.chartArea;
                                
                                // Get colors for azimuths
                                const oppositeAzimuth = (azimuth + 180) % 360;
                                const currentColor = getAzimuthColor(azimuth).line;
                                const oppositeColor = getAzimuthColor(oppositeAzimuth).line;
                                
                                ctx.save();
                                ctx.font = 'bold 16px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'top';
                                
                                // Left side label (opposite azimuth)
                                if (scale.min < 0) {
                                    const leftX = chartArea.left + (scale.getPixelForValue(0) - chartArea.left) / 2;
                                    const labelY = chartArea.top + 20;
                                    ctx.fillStyle = oppositeColor;
                                    ctx.fillText(`${oppositeAzimuth}°`, leftX, labelY);
                                }
                                
                                // Right side label (current azimuth)  
                                if (scale.max > 0) {
                                    const rightX = scale.getPixelForValue(0) + (chartArea.right - scale.getPixelForValue(0)) / 2;
                                    const labelY = chartArea.top + 20;
                                    ctx.fillStyle = currentColor;
                                    ctx.fillText(`${azimuth}°`, rightX, labelY);
                                }
                                
                                ctx.restore();
                            }
                        }
                    }
                }
            });
            chart.$azimuth = azimuth;
            
            // Enhanced click handler with floating tools support
            chart.canvas.onclick = (evt) => {
                handleFloatingChartInteraction(chart, evt, azimuth);
            };
            
            // Add context menu handler for right-click detection  
            chart.canvas.oncontextmenu = (evt) => {
                evt.preventDefault();
                handleFloatingChartInteraction(chart, evt, azimuth);
            };
            
            // Store azimuth reference
            chart.azimuth = azimuth;
            chartInstances[azimuth] = chart;
            
            // Set up mouse handlers for this specific chart (delayed to ensure DOM is ready)
            setTimeout(() => setupChartMouseHandlers(), 10);
        }

        function updateGridLayout() {
            const container = document.getElementById('card-container');
            const visibleCards = Array.from(container.querySelectorAll('.kzt-card'));
            visibleCards.forEach(card => card.classList.remove('lg:col-span-2'));
            if (visibleCards.length % 2 !== 0) {
                const lastVisibleCard = visibleCards[visibleCards.length - 1];
                if (lastVisibleCard) { lastVisibleCard.classList.add('lg:col-span-2'); }
            }
        }
        
        function renderAll(results) {
            renderControlPanel(results);
            renderCollapsedBar(results);
            renderAzimuthCards(results);
            renderControllingCaseCard(results);
            updateGridLayout();
            // Render charts shortly after DOM updates to avoid layout thrash
            setTimeout(renderCharts, 60);
        }

        // CONTROL PANEL FUNCTIONS
        function handleDockToggle() {
            const visibleCount = sampleResults.filter(r => r.status === 'success' && !r.isCollapsed).length;
            if (visibleCount > 0) {
                handleDockAll();
            } else {
                handleUndockAll();
            }
        }
        
        function handleIncludeToggle() {
            const excludedCount = sampleResults.filter(r => r.status === 'success' && !r.isIncluded).length;
            if (excludedCount > 0) {
                handleIncludeAll();
            } else {
                handleExcludeAll();
            }
        }
        
        function handleExpandCollapseToggle() {
            const visibleCards = document.querySelectorAll('.kzt-card:not([style*="display: none"])');
            if (visibleCards.length === 0) return;
            
            // Check if most sections are expanded or collapsed
            let expandedSections = 0;
            let totalSections = 0;
            
            visibleCards.forEach(card => {
                const sections = card.querySelectorAll('.card-section-header[data-section-key]');
                sections.forEach(sectionHeader => {
                    const content = sectionHeader.nextElementSibling;
                    if (content) {
                        totalSections++;
                        if (!content.classList.contains('is-collapsed')) {
                            expandedSections++;
                        }
                    }
                });
            });
            
            // If more than half are expanded, collapse all. Otherwise, expand all.
            if (expandedSections > totalSections / 2) {
                handleCollapseAllSections();
            } else {
                handleExpandAllSections();
            }
        }

        function handleDockAll() {
            const visibleResults = sampleResults.filter(r => r.status === 'success' && !r.isCollapsed);
            if (visibleResults.length === 0) return;
            
            // Animate collapse for all visible cards
            const promises = visibleResults.map(result => {
                return new Promise(resolve => {
                    const card = document.getElementById(`kzt-card-${result.windDirection}`);
                    if (!card) {
                        resolve();
                        return;
                    }
                    
                    // Add hiding class for smooth transition
                    card.classList.add('is-hiding');
                    result.isCollapsed = true;
                    
                    setTimeout(() => {
                        resolve();
                    }, 200); // Transition duration
                });
            });
            
            Promise.all(promises).then(() => {
                renderAll(sampleResults);
            });
        }
        
        function handleUndockAll() {
            const collapsedResults = sampleResults.filter(r => r.status === 'success' && r.isCollapsed);
            if (collapsedResults.length === 0) return;

            // Pre-restore all collapsed cards data
            collapsedResults.forEach(result => { result.isCollapsed = false; });

            // Render updated DOM first
            renderAll(sampleResults);

            // Staggered enter animation with ensured reflow
            setTimeout(() => {
                const newCards = document.querySelectorAll('.kzt-card');
                newCards.forEach((card, index) => {
                    // Set initial state without transition
                    card.style.transition = 'none';
                    card.style.opacity = '0';
                    card.style.transform = 'translateY(16px) scale(0.98)';

                    // Force reflow to commit initial styles
                    void card.offsetWidth; // reflow

                    const dur = getAnimationDuration(400);
                    const delay = getAnimationDelay(index * 80);
                    card.style.transition = `opacity ${dur}ms ease-out ${delay}ms, transform ${dur}ms cubic-bezier(0.2, 0.8, 0.2, 1) ${delay}ms`;

                    // Next frame: animate to final state
                    requestAnimationFrame(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'translateY(0) scale(1)';
                    });

                    // Cleanup inline transition after it runs
                    const onEnd = () => {
                        card.style.transition = '';
                        card.removeEventListener('transitionend', onEnd);
                    };
                    card.addEventListener('transitionend', onEnd, { once: true });
                });
            }, 30);
        }
        
        function handleToggleSection(sectionKey, forceState = null) {
            const visibleCards = document.querySelectorAll('.kzt-card:not([style*="display: none"])');
            if (visibleCards.length === 0) return;
            
            // Determine current state if not forced
            let shouldExpand = forceState;
            if (shouldExpand === null) {
                const visibleSections = Array.from(visibleCards).filter(card => {
                    const section = card.querySelector(`[data-section-key="${sectionKey}"] + .collapsible-content`);
                    return section && !section.classList.contains('is-collapsed');
                });
                shouldExpand = visibleSections.length === 0;
            }
            
            visibleCards.forEach(card => {
                const sectionHeader = card.querySelector(`[data-section-key="${sectionKey}"]`);
                if (!sectionHeader) return;
                
                const content = sectionHeader.nextElementSibling;
                const icon = sectionHeader.querySelector('.card-section-toggle');
                
                if (!content || !icon) return;
                
                if (shouldExpand) {
                    expandSection(content, icon);
                    if (sectionKey === 'graph') {
                        // Re-render charts for graphs section
                        setTimeout(() => {
                            const azimuth = card.dataset.azimuth;
                            if (azimuth) renderSingleChart(parseInt(azimuth));
                        }, 300);
                    }
                } else {
                    collapseSection(content, icon);
                }
                
                // Apply mirroring if enabled
                if (shouldMirrorSections()) {
                    mirrorSectionState(card, sectionKey, shouldExpand);
                }
            });
            
            // Update control panel to reflect new state
            setTimeout(() => {
                renderControlPanel(sampleResults);
            }, 100);
        }
        
        function handleExpandAllSections() {
            const visibleCards = document.querySelectorAll('.kzt-card:not([style*="display: none"])');
            
            visibleCards.forEach(card => {
                const sections = card.querySelectorAll('.card-section-header[data-section-key]');
                sections.forEach(sectionHeader => {
                    const content = sectionHeader.nextElementSibling;
                    const icon = sectionHeader.querySelector('.card-section-toggle');
                    
                    if (content && icon && content.classList.contains('is-collapsed')) {
                        expandSection(content, icon);
                        
                        // Re-render charts for graphs section
                        const sectionKey = sectionHeader.dataset.sectionKey;
                        if (sectionKey === 'graph') {
                            setTimeout(() => {
                                const azimuth = card.dataset.azimuth;
                                if (azimuth) renderSingleChart(parseInt(azimuth));
                            }, 300);
                        }
                    }
                });
            });
            
            setTimeout(() => {
                renderControlPanel(sampleResults);
            }, 100);
        }
        
        function handleCollapseAllSections() {
            const visibleCards = document.querySelectorAll('.kzt-card:not([style*="display: none"])');
            
            visibleCards.forEach(card => {
                const sections = card.querySelectorAll('.card-section-header[data-section-key]');
                sections.forEach(sectionHeader => {
                    const content = sectionHeader.nextElementSibling;
                    const icon = sectionHeader.querySelector('.card-section-toggle');
                    
                    if (content && icon && !content.classList.contains('is-collapsed')) {
                        collapseSection(content, icon);
                    }
                });
            });
            
            setTimeout(() => {
                renderControlPanel(sampleResults);
            }, 100);
        }
        
        function handleIncludeAll() {
            // Handle visible cards
            const cards = document.querySelectorAll('.kzt-card');
            cards.forEach(card => {
                const checkbox = card.querySelector('.include-checkbox');
                const azimuth = card.dataset.azimuth;
                const result = sampleResults.find(r => r.windDirection == azimuth);
                
                if (checkbox && result && !result.isIncluded) {
                    checkbox.checked = true;
                    result.isIncluded = true;
                    card.classList.remove('is-excluded');
                }
            });
            
            // Handle docked cards (collapsed badges)
            const dockedBadges = document.querySelectorAll('.collapsed-badge');
            dockedBadges.forEach(badge => {
                const azimuth = badge.dataset.azimuth;
                const result = sampleResults.find(r => r.windDirection == azimuth);
                
                if (result && !result.isIncluded) {
                    result.isIncluded = true;
                    badge.classList.remove('line-through', 'opacity-70');
                }
            });
            
            renderControllingCaseCard(sampleResults);
            renderControlPanel(sampleResults);
        }
        
        function handleExcludeAll() {
            // Handle visible cards
            const cards = document.querySelectorAll('.kzt-card');
            cards.forEach(card => {
                const checkbox = card.querySelector('.include-checkbox');
                const azimuth = card.dataset.azimuth;
                const result = sampleResults.find(r => r.windDirection == azimuth);
                
                if (checkbox && result && result.isIncluded) {
                    checkbox.checked = false;
                    result.isIncluded = false;
                    card.classList.add('is-excluded');
                }
            });
            
            // Handle docked cards (collapsed badges)
            const dockedBadges = document.querySelectorAll('.collapsed-badge');
            dockedBadges.forEach(badge => {
                const azimuth = badge.dataset.azimuth;
                const result = sampleResults.find(r => r.windDirection == azimuth);
                
                if (result && result.isIncluded) {
                    result.isIncluded = false;
                    badge.classList.add('line-through', 'opacity-70');
                }
            });
            
            renderControllingCaseCard(sampleResults);
            renderControlPanel(sampleResults);
        }

        function handleResetDefaults() {
            // Reset all cards to default state: summaries expanded, others collapsed
            const visibleCards = document.querySelectorAll('.kzt-card:not([style*="display: none"])');
            
            visibleCards.forEach(card => {
                const sections = card.querySelectorAll('.card-section-header[data-section-key]');
                sections.forEach(sectionHeader => {
                    const sectionKey = sectionHeader.dataset.sectionKey;
                    const content = sectionHeader.nextElementSibling;
                    const icon = sectionHeader.querySelector('.card-section-toggle');
                    
                    if (!content || !icon) return;
                    
                    if (sectionKey === 'summaries') {
                        // Expand summaries by default
                        if (content.classList.contains('is-collapsed')) {
                            expandSection(content, icon);
                        }
                    } else {
                        // Collapse other sections by default
                        if (!content.classList.contains('is-collapsed')) {
                            collapseSection(content, icon);
                        }
                    }
                });
            });
            
            // Reset mirror sections state
            state.mirrorSectionsLg = true;
            const mirrorToggle = document.getElementById('control-mirror-sections-toggle');
            if (mirrorToggle) {
                mirrorToggle.checked = true;
            }
            
            setTimeout(() => {
                renderControlPanel(sampleResults);
            }, 100);
        }

        // ANIMATION HANDLERS
        function handleCollapse(collapseBtn) {
            const card = collapseBtn.closest('.kzt-card');
            if (!card) return;
            
            const azimuth = card.dataset.azimuth;
            const result = sampleResults.find(r => r.windDirection == azimuth);
            if (!result) return;
            
            const firstPositions = new Map();
            document.querySelectorAll('.kzt-card').forEach(c => {
                firstPositions.set(c.dataset.azimuth, c.getBoundingClientRect());
            });
            
            const cardRect = firstPositions.get(azimuth);
            const ghost = card.cloneNode(true);
            ghost.classList.add('kzt-card-ghost');
            ghost.style.top = `${cardRect.top}px`;
            ghost.style.left = `${cardRect.left}px`;
            ghost.style.width = `${cardRect.width}px`;
            ghost.style.height = `${cardRect.height}px`;
            document.body.appendChild(ghost);
            
            card.style.opacity = '0';
            result.isCollapsed = true;
            renderAll(sampleResults);
            
            const dock = document.getElementById('collapsed-bar');
            const badge = dock ? dock.querySelector(`.restore-btn[data-azimuth="${azimuth}"]`) : null;
            if (!badge) {
                if (document.body.contains(ghost)) document.body.removeChild(ghost);
                return;
            }
            
            const badgeRect = badge.getBoundingClientRect();
            badge.classList.add('is-animating');
            
            document.querySelectorAll('.kzt-card').forEach(otherCard => {
                const id = otherCard.dataset.azimuth;
                const firstRect = firstPositions.get(id);
                const lastRect = otherCard.getBoundingClientRect();
                if (!firstRect) return;
                
                const deltaX = firstRect.left - lastRect.left;
                const deltaY = firstRect.top - lastRect.top;
                if (Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5) {
                    otherCard.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    requestAnimationFrame(() => {
                        otherCard.classList.add('kzt-card-restoring');
                        otherCard.style.transform = '';
                        otherCard.addEventListener('transitionend', () => {
                            otherCard.classList.remove('kzt-card-restoring');
                        }, { once: true });
                    });
                }
            });
            
            requestAnimationFrame(() => {
                const deltaX = badgeRect.left - cardRect.left;
                const deltaY = badgeRect.top - cardRect.top;
                const scaleX = badgeRect.width / cardRect.width;
                const scaleY = badgeRect.height / cardRect.height;
                ghost.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`;
                ghost.style.opacity = '0';
                ghost.addEventListener('transitionend', () => {
                    if (document.body.contains(ghost)) {
                        document.body.removeChild(ghost);
                    }
                    if (badge) {
                        badge.classList.remove('is-animating');
                    }
                }, { once: true });
            });
        }
        
        function handleRestore(restoreBtn) {
            const azimuth = restoreBtn.dataset.azimuth;
            const result = sampleResults.find(r => r.windDirection == azimuth);
            if (!result) return;
            
            const badgeRect = restoreBtn.getBoundingClientRect();
            restoreBtn.classList.add('is-animating');
            
            const firstPositions = new Map();
            document.querySelectorAll('.kzt-card').forEach(card => {
                firstPositions.set(card.dataset.azimuth, card.getBoundingClientRect());
            });
            
            result.isCollapsed = false;
            renderAll(sampleResults);
            
            const cardToRestore = document.getElementById(`kzt-card-${azimuth}`);
            if (!cardToRestore) return;
            
            // Force all sections to be collapsed initially for the restored card
            // First, let the browser calculate the natural heights
            cardToRestore.querySelectorAll('.collapsible-content').forEach(content => {
                // Remove collapsed class temporarily to get natural height
                content.classList.remove('is-collapsed');
                content.style.maxHeight = 'none';
                
                // Force a layout calculation
                const naturalHeight = content.scrollHeight;
                
                // Set to natural height first, then immediately collapse
                content.style.maxHeight = naturalHeight + 'px';
                
                // Force reflow
                content.offsetHeight;
                
                // Now collapse with animation
                content.classList.add('is-collapsed');
                content.style.maxHeight = '0px';
            });
            
            cardToRestore.querySelectorAll('.card-section-toggle').forEach(icon => {
                icon.classList.add('is-collapsed');
            });
            
            const lastCardRect = cardToRestore.getBoundingClientRect();
            cardToRestore.style.opacity = '0';
            
            const ghost = cardToRestore.cloneNode(true);
            ghost.classList.add('kzt-card-ghost');
            ghost.style.top = `${lastCardRect.top}px`;
            ghost.style.left = `${lastCardRect.left}px`;
            ghost.style.width = `${lastCardRect.width}px`;
            ghost.style.height = `${lastCardRect.height}px`;
            
            const deltaX = badgeRect.left - lastCardRect.left;
            const deltaY = badgeRect.top - lastCardRect.top;
            const scaleX = badgeRect.width / lastCardRect.width;
            const scaleY = badgeRect.height / lastCardRect.height;
            
            ghost.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`;
            ghost.style.opacity = '0';
            ghost.style.transition = `transform 0.45s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s ease-out`;
            document.body.appendChild(ghost);
            
            document.querySelectorAll('.kzt-card').forEach(card => {
                const id = card.dataset.azimuth;
                if (id === azimuth) return;
                
                const firstRect = firstPositions.get(id);
                const lastRect = card.getBoundingClientRect();
                if (!firstRect) return;
                
                const dx = firstRect.left - lastRect.left;
                const dy = firstRect.top - lastRect.top;
                if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                    card.style.transform = `translate(${dx}px, ${dy}px)`;
                    requestAnimationFrame(() => {
                        card.classList.add('kzt-card-restoring');
                        card.style.transform = '';
                        card.addEventListener('transitionend', () => {
                            card.classList.remove('kzt-card-restoring');
                        }, { once: true });
                    });
                }
            });
            
            requestAnimationFrame(() => {
                ghost.style.transform = 'translate(0, 0) scale(1)';
                ghost.style.opacity = '1';
                ghost.addEventListener('transitionend', () => {
                    // Temporarily disable transitions to avoid blink
                    cardToRestore.style.transition = 'none';
                    cardToRestore.style.opacity = '1';
                    // Re-enable transitions after a minimal delay
                    requestAnimationFrame(() => {
                        cardToRestore.style.transition = '';
                        
                        // After the card is fully restored, apply mirroring logic
                        setTimeout(() => {
                            applyMirroringToRestoredCard(cardToRestore);
                        }, 150);
                    });
                    if (document.body.contains(ghost)) {
                        document.body.removeChild(ghost);
                    }
                }, { once: true });
            });
        }
        
        function applyMirroringToRestoredCard(restoredCard) {
            if (!shouldMirrorSections()) {
                // If mirroring is disabled, apply default section states
                applyDefaultSectionStates(restoredCard);
                return;
            }
            
            const mirrorCard = findMirrorCard(restoredCard);
            if (!mirrorCard) {
                // No mirror card available (e.g., only one card visible), apply default section states
                applyDefaultSectionStates(restoredCard);
                return;
            }
            
            // Get all section states from the mirror card
            const mirrorSections = mirrorCard.querySelectorAll('.card-section-header[data-section-key]');
            
            mirrorSections.forEach(mirrorSectionHeader => {
                const sectionKey = mirrorSectionHeader.dataset.sectionKey;
                const mirrorContent = mirrorSectionHeader.nextElementSibling;
                const isMirrorExpanded = mirrorContent && !mirrorContent.classList.contains('is-collapsed');
                
                // Find corresponding section in restored card
                const restoredSectionHeader = restoredCard.querySelector(`[data-section-key="${sectionKey}"]`);
                if (!restoredSectionHeader) return;
                
                const restoredContent = restoredSectionHeader.nextElementSibling;
                const restoredIcon = restoredSectionHeader.querySelector('.card-section-toggle');
                
                if (!restoredContent || !restoredIcon) return;
                
                // Apply the mirror card's state to the restored card
                if (isMirrorExpanded) {
                    // Use a slight staggered delay for a more natural feel
                    const delay = sectionKey === 'summaries' ? 0 : 100;
                    setTimeout(() => {
                        expandSection(restoredContent, restoredIcon);
                        
                        // If this is a graph section, render the chart
                        if (sectionKey === 'graph') {
                            const azimuth = restoredCard.dataset.azimuth;
                            if (azimuth) {
                                setTimeout(() => renderSingleChart(parseInt(azimuth)), 150);
                            }
                        }
                    }, delay);
                } else {
                    // Section should remain collapsed (already is)
                    collapseSection(restoredContent, restoredIcon);
                }
            });
        }
        
        function applyDefaultSectionStates(restoredCard) {
            // Apply default section states when no mirroring is available
            // By default, expand the summaries section, keep others collapsed
            const summariesSection = restoredCard.querySelector('[data-section-key="summaries"]');
            if (summariesSection) {
                const content = summariesSection.nextElementSibling;
                const icon = summariesSection.querySelector('.card-section-toggle');
                if (content && icon) {
                    // Expand summaries section with animation
                    expandSection(content, icon);
                }
            }
            
            // Keep other sections collapsed (they already are from the restore process)
            const otherSections = restoredCard.querySelectorAll('[data-section-key]:not([data-section-key="summaries"])');
            otherSections.forEach(sectionHeader => {
                const content = sectionHeader.nextElementSibling;
                const icon = sectionHeader.querySelector('.card-section-toggle');
                if (content && icon) {
                    collapseSection(content, icon);
                }
            });
        }
        
        // =================================================================================
        // EVENT LISTENERS & INITIALIZATION
        // =================================================================================

        function setupEventListeners() {
            const mainContainer = document.querySelector('.max-w-7xl');
            const managerCardContainer = document.getElementById('manager-card-container');
            const cardContainer = document.getElementById('card-container');

            const clearLongPress = () => { clearTimeout(longPressTimer); };

            mainContainer.addEventListener('mousedown', (event) => {
                const unitToggleEl = event.target.closest('.unit-toggle');
                const coordToggleEl = event.target.closest('.coord-toggle');

                if (unitToggleEl || coordToggleEl) {
                    longPressTimer = setTimeout(() => {
                        if (unitToggleEl) {
                            const paramKey = unitToggleEl.dataset.paramKey;
                            if (paramKey && state.units[paramKey]) {
                                state.units[paramKey] = getNextUnit(state.units[paramKey]);
                                if (['H', 'Lh', 'x', 'z', 'Top', 'Mid', 'Bottom', 'crestElev', 'structElev'].includes(paramKey)) {
                                    state.units.profileElevation = getNextUnit(state.units.profileElevation);
                                }
                                if (['L', 'distToMid', 'x', 'Lh'].includes(paramKey)){
                                    state.units.profileDistance = getNextUnit(state.units.profileDistance);
                                }
                                updateUnitDisplays();
                                renderCharts(); // Only re-render charts that use units
                            }
                        }
                        if (coordToggleEl) {
                            state.coordinateFormat = state.coordinateFormat === 'dd' ? 'dms' : 'dd';
                            updateCoordinateDisplays();
                        }
                    }, 500); // 500ms for long press
                }
            });

            mainContainer.addEventListener('mouseup', clearLongPress);
            mainContainer.addEventListener('mouseleave', clearLongPress);
            mainContainer.addEventListener('dragstart', clearLongPress);


            mainContainer.addEventListener('click', (event) => {
                const collapseBtn = event.target.closest('.collapse-btn');
                const restoreBtn = event.target.closest('.restore-btn');
                const sectionCollapseBtn = event.target.closest('.section-collapse-btn');
                
                // Control panel buttons
                const dockToggleBtn = event.target.closest('.dock-toggle-btn');
                const includeToggleBtn = event.target.closest('.include-toggle-btn');
                const toggleSummariesBtn = event.target.closest('.toggle-summaries-btn');
                const toggleMatrixBtn = event.target.closest('.toggle-matrix-btn');
                const toggleGraphsBtn = event.target.closest('.toggle-graphs-btn');
                const expandCollapseToggleBtn = event.target.closest('.expand-collapse-toggle-btn');
                const resetDefaultsBtn = event.target.closest('.reset-defaults-btn');

                if (collapseBtn) { handleCollapse(collapseBtn); }
                if (restoreBtn) { handleRestore(restoreBtn); }
                if (sectionCollapseBtn) {
                    event.stopPropagation();
                    const content = sectionCollapseBtn.nextElementSibling;
                    const icon = sectionCollapseBtn.querySelector('.card-section-toggle');
                    const currentCard = sectionCollapseBtn.closest('.kzt-card');
                    const sectionKey = getSectionKey(sectionCollapseBtn);
                    
                    if (content.classList.contains('is-collapsed')) {
                        expandSection(content, icon);
                        // Mirror the expansion
                        mirrorSectionState(currentCard, sectionKey, true);
                        
                        // If this is a graph section, render the chart after a short delay
                        if (sectionKey === 'graph') {
                            const azimuth = currentCard.dataset.azimuth;
                            if (azimuth) {
                                setTimeout(() => renderSingleChart(parseInt(azimuth)), 150);
                            }
                        }
                    } else {
                        collapseSection(content, icon);
                        // Mirror the collapse
                        mirrorSectionState(currentCard, sectionKey, false);
                    }
                    
                    // Update control panel
                    setTimeout(() => {
                        renderControlPanel(sampleResults);
                    }, 100);
                }
                
                // Control panel handlers
                if (dockToggleBtn) { handleDockToggle(); }
                if (includeToggleBtn) { handleIncludeToggle(); }
                if (toggleSummariesBtn) { 
                    const currentState = toggleSummariesBtn.dataset.state;
                    handleToggleSection('summaries', currentState === 'hidden');
                }
                if (toggleMatrixBtn) { 
                    const currentState = toggleMatrixBtn.dataset.state;
                    handleToggleSection('matrix', currentState === 'hidden');
                }
                if (toggleGraphsBtn) { 
                    const currentState = toggleGraphsBtn.dataset.state;
                    handleToggleSection('graph', currentState === 'hidden');
                }
                if (expandCollapseToggleBtn) { handleExpandCollapseToggle(); }
                if (resetDefaultsBtn) { handleResetDefaults(); }
            });

            cardContainer.addEventListener('change', (event) => {
                const target = event.target;
                if (target.type === 'radio' && target.name.startsWith('kzt-override-')) {
                    const card = target.closest('.kzt-card');
                    const azimuth = card.dataset.azimuth;
                    const result = sampleResults.find(r => r.windDirection == azimuth);
                    if (card && result) {
                        result.defaultKzt = parseFloat(target.value);
                        result.defaultShape = target.dataset.topo;
                        result.defaultExposure = target.dataset.exp;
                        card.querySelector('.final-kzt-value').textContent = result.defaultKzt.toFixed(3);
                        checkAndUpdateGlobalControls();
                        renderControllingCaseCard(sampleResults);
                    }
                }
                if (target.classList.contains('include-checkbox')) {
                    const azimuth = target.dataset.azimuth;
                    const result = sampleResults.find(r => r.windDirection == azimuth);
                    if (result) {
                        result.isIncluded = target.checked;
                        
                        // Update only the specific card's visual state
                        const card = target.closest('.kzt-card');
                        if (card) {
                            card.classList.toggle('is-excluded', !result.isIncluded);
                        }
                        
                        // Update controlling case without full re-render
                        renderControllingCaseCard(sampleResults);
                    }
                }
            });

            managerCardContainer.addEventListener('change', () => {
                const selectedExp = document.getElementById('global-exposure-select').value;
                const selectedTopo = document.getElementById('global-topo-select').value;
                
                const changeEvent = new Event('change', { bubbles: true });
                document.querySelectorAll('.kzt-card').forEach(card => {
                    const checked = card.querySelector('input[type="radio"]:checked');
                    const targetTopo = (selectedTopo === 'by-azimuth') ? checked.dataset.topo : selectedTopo;
                    const targetExp = (selectedExp === 'by-azimuth') ? checked.dataset.exp : selectedExp;
                    const targetRadio = card.querySelector(`input[data-topo="${targetTopo}"][data-exp="${targetExp}"]`);
                    if (targetRadio && !targetRadio.checked) {
                        targetRadio.checked = true;
                        targetRadio.dispatchEvent(changeEvent);
                    }
                });
            });

            // Control panel event listeners
        document.addEventListener('change', (event) => {
                if (event.target.id === 'control-mirror-sections-toggle') {
                    state.mirrorSectionsLg = event.target.checked;
                } else if (event.target.id === 'control-animation-speed-slider') {
            updateAnimationSpeed(event.target.value);
                }
            });
        }

        function checkAndUpdateGlobalControls() {
            const expSelect = document.getElementById('global-exposure-select');
            const topoSelect = document.getElementById('global-topo-select');
            const cards = Array.from(document.querySelectorAll('.kzt-card'));
            if (cards.length < 2) return;
            const firstExp = cards[0].querySelector('input[type="radio"]:checked').dataset.exp;
            if (cards.slice(1).some(c => c.querySelector('input[type="radio"]:checked').dataset.exp !== firstExp)) {
                expSelect.value = 'by-azimuth';
            }
            const firstTopo = cards[0].querySelector('input[type="radio"]:checked').dataset.topo;
            if (cards.slice(1).some(c => c.querySelector('input[type="radio"]:checked').dataset.topo !== firstTopo)) {
                topoSelect.value = 'by-azimuth';
            }
        }
        
        // --- INITIALIZATION --- For a real application, you might call `initializeApp` manually after fetching data.
        function initializeApp(results) {
            // Enforce default collapsed state on first load if property missing
            results.forEach(r => {
                if (r && r.status === 'success' && typeof r.isCollapsed === 'undefined') {
                    r.isCollapsed = !!state.allCardsDocked;
                }
                if (r && r.status === 'success' && typeof r.isIncluded === 'undefined') {
                    r.isIncluded = true;
                }
            });
            updateAnimationCSSVariables(); // Initialize CSS animation variables
            renderManagerCard();
            renderAll(results);
            setupEventListeners();
            
            // Initialize floating tool palette system
            initializeFloatingToolPalette();
            
            // Initialize floating annotation editor system
            initializeFloatingAnnotationEditor();
            
            // Add resize listener for mirror sections
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateGridLayout();
                    // Mirror sections only work on large screens
                    if (!shouldMirrorSections()) {
                        // Optionally disable visual feedback when not applicable
                        const toggle = document.getElementById('mirror-sections-toggle');
                        if (toggle) {
                            toggle.parentElement.style.opacity = window.innerWidth >= 1024 ? '1' : '0.6';
                        }
                    }
                }, 100);
            });
            
            // Add staggered animation on load
            setTimeout(() => {
                const managerCard = document.getElementById('manager-card');
                const controllingCard = document.getElementById('controlling-case-card');
                const collapsedBar = document.getElementById('collapsed-bar');
                const cards = document.querySelectorAll('.kzt-card');
                
                if (managerCard) {
                    managerCard.classList.add('fade-in-up');
                }
                if (controllingCard) {
                    controllingCard.classList.add('fade-in-up', 'delay-1');
                }
                // Avoid applying generic fade-in to the dock to prevent flicker
                
                cards.forEach((card, index) => {
                    card.classList.add('fade-in-up', `delay-${Math.min(index + 3, 4)}`);
                });
            }, 50);
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeApp(sampleResults);
        });
    </script>
</body>
</html>>